<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-java" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/26/java/" class="article-date">
  <time class="dt-published" datetime="2025-10-26T13:52:39.394Z" itemprop="datePublished">2025-10-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/26/java/">Java</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Java"><a href="#Java" class="headerlink" title=" Java"></a><center> Java</h1><h2 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h2><h3 id="一、安装Java-Development-Kit（JDK）"><a href="#一、安装Java-Development-Kit（JDK）" class="headerlink" title="一、安装Java Development Kit（JDK）"></a>一、安装Java Development Kit（JDK）</h3><ol>
<li><strong>javac和java</strong></li>
</ol>
<ul>
<li>java:执行工具</li>
<li>javac：编译工具</li>
</ul>
<ol start="2">
<li><strong>jdk的组成</strong><ol>
<li>JVM（Java Virtual Machine）：Java虚拟机，真正运行Java程序的地方</li>
<li>核心类库（API）：Java自己写好的程序，给程序员自己的程序调用的</li>
</ol>
</li>
</ol>
<ul>
<li>JVM和核心类库构成<strong>JRE</strong>（Java Runtime Environment）：Java的运行环境</li>
<li><strong>JRE</strong>和<strong>开发工具</strong>构成JDK（Java Development Kit）：Java开发工具包（包括上面所有）</li>
</ul>
<h3 id="二、配置环境变量"><a href="#二、配置环境变量" class="headerlink" title="二、配置环境变量"></a>二、配置环境变量</h3><ul>
<li>Path环境变量可用于配置程序的所在路径，以方便在命令行窗口的任意目录下直接通过命令启动该程序（<strong>目的：可以在任何位置上运行Java命令</strong>）<br>1.<strong>注意事项</strong></li>
<li>目前较新的JDK在安装时，<strong>会自动配置javac、java程序的路径到Path环境变量中</strong></li>
<li>较老版本的JDK不会自动配置，需要手动配置</li>
<li>建议为JDK再配置JAVA_HOME环境变量</li>
</ul>
<ol start="2">
<li><strong>建议为JDK再配置JAVA_HOME环境变量</strong></li>
</ol>
<ul>
<li><strong>JAVA_HOME：</strong> 是用于告诉操作系统JDK安装在了哪个位置（将来其他技术要通过这个环境变量找JDK）</li>
<li>配置后建议把Path中改为%JAVA_HOME%\bin，这样更新时只用更改一处</li>
</ul>
<h3 id="三、选择开发工具"><a href="#三、选择开发工具" class="headerlink" title="三、选择开发工具"></a>三、选择开发工具</h3><p>文本编辑器&#x2F;集成开发环境（IDE）</p>
<h3 id="四、创建第一个Java程序"><a href="#四、创建第一个Java程序" class="headerlink" title="四、创建第一个Java程序"></a>四、创建第一个Java程序</h3><p><strong>使用文本编辑器+命令行</strong></p>
<ol>
<li>编写代码：使用文本编辑器创建“HelloWorld.java”文本文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		System.out.println(&quot;Hello,World!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编译代码:打开命令行窗口，切换到.java文件所在目录，然后输入<code>javac HelloWorld.java</code>来编译代码，如果一切正常，这将会生成一个<code>HelloWorld.class</code>文件</li>
<li>运行程序：在同一命令行窗口，输入<code>java HelloWorld</code>来运行程序，输出<code>&quot;Hello,World!&quot;</code></li>
</ol>
<h3 id="四、使用IDEA开发第一个Java程序的步骤"><a href="#四、使用IDEA开发第一个Java程序的步骤" class="headerlink" title="四、使用IDEA开发第一个Java程序的步骤"></a>四、使用IDEA开发第一个Java程序的步骤</h3><ol>
<li><strong>创建工程 new Project</strong><br>建议先不要建java工程，建Empty Project</li>
<li><strong>创建模块 new Module</strong></li>
<li><strong>创建包 new Package</strong><br>包一定要建在模块下<br>包名：公司域名的倒写<br>例：<a href="http://www.itheima.com->">www.itheima.com-&gt;</a><br>com.itheima.技术名称(全部用英文小写)</li>
<li><strong>创建类（类名不要带后缀）</strong><br>编译后的class文件在工程路径下的一个<strong>out</strong>文件夹里</li>
</ol>
<h3 id="五、快捷键"><a href="#五、快捷键" class="headerlink" title="五、快捷键"></a>五、快捷键</h3><table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">main&#x2F;psvm、sout</td>
<td align="center">快速键入相关代码</td>
</tr>
<tr>
<td align="center">Ctrl+D</td>
<td align="center">复制当前行数据到下一行</td>
</tr>
<tr>
<td align="center">Ctrl+Y</td>
<td align="center">删除所在行，建议用Ctrl+X</td>
</tr>
<tr>
<td align="center">Ctrl+Alt+L</td>
<td align="center">格式化代码</td>
</tr>
<tr>
<td align="center">ALT+SHIFT+上，ALT+SHIFT+下</td>
<td align="center">上下移动当前代码</td>
</tr>
<tr>
<td align="center">Ctrl+&#x2F;，Ctrl+Shift+&#x2F;</td>
<td align="center">对代码进行注释</td>
</tr>
</tbody></table>
<h3 id="六、IDEA中的其他操作"><a href="#六、IDEA中的其他操作" class="headerlink" title="六、IDEA中的其他操作"></a>六、IDEA中的其他操作</h3><ol>
<li><strong>导入模块</strong><br>File-&gt;New-&gt;Module from Existing Sources</li>
<li><strong>删除模块</strong><br>先remove再delete</li>
</ol>
<h3 id="七、Java的基本语法"><a href="#七、Java的基本语法" class="headerlink" title="七、Java的基本语法"></a>七、Java的基本语法</h3><ol>
<li>Java开发的软件，功能的最小单位是一个一个的<strong>方法</strong></li>
<li><strong>注释</strong><br>注释方法与c++相同<br><strong>文档注释（通常用在类和方法上方）</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    注释内容</span><br><span class="line">    注释内容</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li>
<li><strong>数据类型</strong><br>字符串类型：<strong>String</strong>（大写）<br>基本数据类型转换成String类型：<code>...+ &quot;&quot;</code><br>布尔值类型：<strong>boolean</strong>（默认为false）</li>
<li>类型转换<br>表达式类型转换：</li>
</ol>
<ul>
<li><strong>表达式的最终结果类型由表达式中的最高类型决定</strong></li>
<li><strong>在表达式中，byte、short、char</strong>是<strong>直接转换成int</strong>类型参与运算的</li>
</ul>
<h2 id="day2"><a href="#day2" class="headerlink" title="day2"></a>day2</h2><h3 id="一、输入输出"><a href="#一、输入输出" class="headerlink" title="一、输入输出"></a>一、输入输出</h3><p><strong>步骤</strong>：</p>
<ol>
<li>导包：告诉程序去JDK的哪个包中找扫描器技术<code>import java.util.Scanner</code></li>
<li>创建键盘扫描器对象<code>Scanner sc=new Scanner(System.in)</code></li>
<li>等待接收用户输入数据<br><code>String name=sc.nextLine();</code><br><code>int age=sc.nextInt();</code></li>
</ol>
<ul>
<li>注意：System、String在JDK中的<strong>Java.lang</strong>包下</li>
<li>lang包不需要我们导包，是默认的包</li>
</ul>
<h3 id="二、扩展赋值运算符"><a href="#二、扩展赋值运算符" class="headerlink" title="二、扩展赋值运算符"></a>二、扩展赋值运算符</h3><p>+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;</p>
<ul>
<li><strong>注意：扩展的赋值运算符隐含了强制类型转换</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">byte a1=10;</span><br><span class="line">byte a2=20;</span><br><span class="line">a1=(byte)(a1+a2);//正常写需要强制类型转换（byte、short、char在参与算数运算时会首先自动提升为int类型）</span><br><span class="line">a1+=a2;//隐含强制类型转换</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="day3"><a href="#day3" class="headerlink" title="day3"></a>day3</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul>
<li><strong>静态初始化数组</strong><br><code>String[] names=&#123;&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;&#125;</code><br>完整定义形式：<br><code>String[] names=new String[]&#123;&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;&#125;</code><br>也可写作<br><code>String names[]=new String[]&#123;&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;&#125;</code><br><strong>随机获取一个索引值</strong><br>Math.random()：0到1之间的小数（左闭右开）<br>names.length：元素个数（与c++区别：没有括号）<br><code>int index=(int)(Math.random()*names.length);</code><br><code>String name=names[index];</code></li>
<li><strong>动态初始化数组</strong><br><code>double[] scores=new double[8];//scores=[0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]（有默认值）</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">double[] scores=new double[8];</span><br><span class="line">Scanner sc=new Scanner(System.in);</span><br><span class="line">for(int i=0;i&lt;scores.length;i++)&#123;</span><br><span class="line">    System.out.println(&quot;请输入第&quot;+(i+1)+&quot;个学生的成绩：&quot;);</span><br><span class="line">    scores[i]=sc.nextDouble();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>二维数组</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[][] matrix=&#123;&#123;&quot;1&quot;,&quot;2&quot;,&quot;3&quot;&#125;,&#123;&quot;4&quot;,&quot;5&quot;,&quot;6&quot;&#125;,&#123;&quot;7&quot;,&quot;8&quot;,&quot;9&quot;&#125;&#125;;</span><br><span class="line">String[][] matrix=new String[][]&#123;&#123;&quot;1&quot;,&quot;2&quot;,&quot;3&quot;&#125;,&#123;&quot;4&quot;,&quot;5&quot;,&quot;6&quot;&#125;,&#123;&quot;7&quot;,&quot;8&quot;,&quot;9&quot;&#125;&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[][] arr=new int[3][5];</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//打印行列信息</span><br><span class="line">for(int i=0;i&lt;3;i++)&#123;</span><br><span class="line">    String[] names=matrix[i];</span><br><span class="line">    for(int j=0;j&lt;3;j++)&#123;</span><br><span class="line">        System.out.print(names[j]+&quot;\t&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="day4"><a href="#day4" class="headerlink" title="day4"></a>day4</h2><h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><ul>
<li><strong>类定义</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Star&#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line">    double height;</span><br><span class="line">    double weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>在计算机中的运行</strong><br><img src="https://pic1.imgdb.cn/item/68c2911d58cb8da5c89cba53.png"></li>
</ul>
<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><ul>
<li><strong>构造器</strong><br>类比与c++的构造函数</li>
<li><strong>this</strong><br>this主要用来解决变量名称冲突问题<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public Student(String name,int age,char sex)&#123;</span><br><span class="line">    this.name=name;</span><br><span class="line">    this.age=age;</span><br><span class="line">    this.sex=sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>封装</strong><br>java风格的私有成员声明<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Student&#123;</span><br><span class="line">    String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private double chinese;</span><br><span class="line">    private double math;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>javabean</strong><br>javabean是一种特殊类（实体类）<br><strong>要求</strong></li>
</ul>
<ol>
<li>类中的成员变量全部私有，并提供public修饰的getter&#x2F;setter方法</li>
<li>类中需要提供一个无参数构造器，有参数构造器可选<br><strong>实体类的基本作用</strong>：创建它的对象，存取数据（封装数据）<br><strong>实体类应用场景</strong>：<br><img src="https://pic1.imgdb.cn/item/68c29c2b58cb8da5c89d12d1.png"></li>
</ol>
<ul>
<li><p><strong>static</strong></p>
<h2 id="可用类名（推荐）-对象访问静态变量-在计算机中的运行-扫描发现存在静态变量后复制一份到堆内存-静态变量的应用场景"><a href="#可用类名（推荐）-对象访问静态变量-在计算机中的运行-扫描发现存在静态变量后复制一份到堆内存-静态变量的应用场景" class="headerlink" title="  可用类名（推荐）&#x2F;对象访问静态变量  - 在计算机中的运行    扫描发现存在静态变量后复制一份到堆内存  静态变量的应用场景  
  "></a>  可用类名（推荐）&#x2F;对象访问静态变量<br>  - <strong>在计算机中的运行</strong><br>  <img src="https://pic1.imgdb.cn/item/68c2a22558cb8da5c89d5bb4.png"><br>  扫描发现存在静态变量后复制一份到堆内存<br><br>  <strong>静态变量的应用场景</strong><br>  <img src="https://pic1.imgdb.cn/item/68c2a30258cb8da5c89d61c9.png">
  </h2><p>  <strong>搞懂main方法</strong><br>  <img src="https://pic1.imgdb.cn/item/68c2a43958cb8da5c89d6aa6.png"></p>
<p>  静态方法的常见应用场景：做工具类</p>
<blockquote>
<p>工具类没有创建对象的需求，建议将工具类的构造器进行私有（不能创建对象）<br>  <img src="https://pic1.imgdb.cn/item/68c2a6bc58cb8da5c89d7c6d.png"></p>
</blockquote>
<p>  <strong>静态方法、实例方法访问注意事项</strong><br>  <img src="https://pic1.imgdb.cn/item/68c2a7d358cb8da5c89d85df.png"></p>
</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li><strong>语法</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class B extends A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>权限修饰符</strong><br><img src="https://pic1.imgdb.cn/item/68c2b80e58cb8da5c89dba52.png"><br>若没有权限修饰符默认为public（与c++区别）</li>
<li><strong>继承的特点</strong><br><img src="https://pic1.imgdb.cn/item/68c2b9c558cb8da5c89dbb86.png"><blockquote>
<p>tips：如果多个类写在一个类中，只能有一个类前面用public修饰</p>
</blockquote>
</li>
</ul>
<p><strong>就近原则</strong><br><img src="https://pic1.imgdb.cn/item/68c2bcf258cb8da5c89dbe35.png"><br><img src="https://pic1.imgdb.cn/item/68c2bd0458cb8da5c89dbe41.png"></p>
<ul>
<li><strong>方法重写</strong><br>其实就是就近原则，要求：方法名称、形参列表必须一样<br>标准写法：在重写方法前写<code>@override</code>（更安全，可读性更好）<br><strong>方法重写的其它注意事项</strong><ol>
<li>子类重写父类方法时，访问权限必须大于或者等于父类该方法的权限<font color=red>（public&gt;protected&gt;缺省）</font></li>
<li>重写的方法返回值类型，必须与被重写方法的返回值类型一样，或者范围更小</li>
<li>私有方法、静态方法不能被重写，如果重写会报错的</li>
</ol>
</li>
</ul>
<p><strong>方法重写在开发中的常见应用场景</strong><br>重写toString方法<br><img src="https://pic1.imgdb.cn/item/68c2c40458cb8da5c89dc386.png"></p>
<ul>
<li><strong>子类构造器的特点</strong><br>子类的全部构造器都会先调用父类的构造器（无参或有参都行），再执行自己的构造器<br><strong>子类构造器是如何实现调用父类构造器的</strong><ul>
<li>默认情况下，子类全部构造器的第一行代码都是<font color=red>super()（写不写都有），它会调用父类的无参数构造器</font></li>
<li>如果父类没有无参数构造器，则我们必须在子类构造器的第一行手写super(…)，指定去调用父类的有参数构造器<br><img src="https://pic1.imgdb.cn/item/68c2c57f58cb8da5c89dc4ba.png"></li>
</ul>
</li>
</ul>
<p><strong>子类构造器调用父类构造器的应用场景</strong><br><img src="https://pic1.imgdb.cn/item/68c2c9ee58cb8da5c89dd93d.png"><br><code>super(name,sex)</code><br>（与c++的初始化列表比较）</p>
<ul>
<li><strong>构造器用this()调用兄弟构造器</strong><br><img src="https://pic1.imgdb.cn/item/68c2ce5358cb8da5c89ded76.png"><br>（类比于c++的委托构造）</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><img src="https://pic1.imgdb.cn/item/68c4e31958cb8da5c8a39850.png"><br>方法：编译看左边，运行看右边<br>成员变量：编译看左边，运行也看左边<br>原因：多态强调的是对象多态、行为多态，并没有强调成员变量多态</p>
<ul>
<li><p><strong>多态的好处和存在的问题</strong><br><strong>好处</strong>：1. 在多态形式下，右边对象是解耦合的（像组件一样可随时更换），更便于扩展和维护2. 定义方法时，使用父类类型的形参，可以接收一切子类对象，扩展性更强、更便利<br><strong>问题</strong>：多态下不能使用子类的独有功能</p>
</li>
<li><p><strong>多态下的类型转换问题</strong><br>强制类型转换：<font color=red>子类 变量名&#x3D;（子类）父类变量</font><br>注意事项：</p>
<ul>
<li>存在继承&#x2F;实现关系就可以在编译阶段进行强制类型转换，编译阶段不会报错</li>
<li>运行时，如果发现对象的真实类型与<font color=red>强转后的类型不同，就会报类型转换异常（ClassCastException）的错误出来</font></li>
</ul>
<p>  <strong>强转前，Java建议：</strong><br>  使用instanceof关键字，判断当前对象的真实类型，再进行强转<br>  <code>p instanceof Student</code></p>
</li>
</ul>
<h2 id="day5"><a href="#day5" class="headerlink" title="day5"></a>day5</h2><h3 id="final关键字-详解-java常量"><a href="#final关键字-详解-java常量" class="headerlink" title="final关键字-详解-java常量"></a>final关键字-详解-java常量</h3><ul>
<li><p><strong>修饰类</strong>：该类被称为最终类，特点是不能被继承了（一般用于修饰工具类）</p>
</li>
<li><p><strong>修饰方法</strong>：该方法被称为最终方法，特点是不能被重写了</p>
</li>
<li><p><strong>修饰变量</strong>：该变量有且仅能被赋值一次</p>
<ol>
<li>成员变量<ol>
<li>静态成员变量（修饰后成为常量，通常用这个值作为系统的配置信息，类比于c++的const）</li>
<li>实例成员变量（final修饰实例变量一般没有意义）</li>
</ol>
</li>
<li>局部变量</li>
</ol>
<ul>
<li>final修饰基本类型的变量，变量存储的<font color=red>数据</font>不能被改变</li>
<li>final修饰引用类型的变量，变量存储的<font color=red>地址</font>不能被改变，但地址所指向对象的内容是可以被改变的</li>
<li>程序编译后，常量会被“宏替换”：出现常量的地方全部会被替换成其记住的字面量，这样可以保证使用常量和直接用字面量的性能是一样的<br>  <img src="https://pic1.imgdb.cn/item/68c4f8e058cb8da5c8a43fa7.png"></li>
</ul>
</li>
</ul>
<h3 id="单例设计模式-懒汉式单例-饿汉式单例"><a href="#单例设计模式-懒汉式单例-饿汉式单例" class="headerlink" title="单例设计模式-懒汉式单例-饿汉式单例"></a>单例设计模式-懒汉式单例-饿汉式单例</h3><p><strong>设计模式</strong>：具体问题的最优解决方案<br><strong>单例设计模式作用</strong>：确保某个类只能创建一个对象<br><img src="https://pic1.imgdb.cn/item/68c4fa8358cb8da5c8a45958.png"></p>
<ul>
<li><strong>饿汉式单例</strong>：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class A&#123;</span><br><span class="line">    //2、定义一个静态变量，用于基本本类的一个唯一对象</span><br><span class="line">    //public static final A a=new A();</span><br><span class="line">    private static A a=new A();//防止类外改成null，造成对象丢失</span><br><span class="line"></span><br><span class="line">    //1、私有化构造器：确保单例类对外不能创建太多对象，单例才有可能性</span><br><span class="line">    private A()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3、提供一个公开的静态方法，返回这个类的唯一对象</span><br><span class="line">    public static A getInstance()&#123;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>懒汉式单例类</strong><br>用对象前，才开始创建对象  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class B&#123;</span><br><span class="line">    //2、私有化静态变量</span><br><span class="line">    private static B b;</span><br><span class="line"></span><br><span class="line">    //1、私有化构造器</span><br><span class="line">    private B()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3、提供静态方法返回对象：真正需要对象的时候才开始创建对象</span><br><span class="line">    public static B getInstance()&#123;</span><br><span class="line">        if(b==null)&#123;</span><br><span class="line">            //第一次拿对象时，会创建对象，给静态变量b记住</span><br><span class="line">            b=new B();</span><br><span class="line">        &#125;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举类的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 enum 枚举类名&#123;</span><br><span class="line">    名称1，名称2，...;</span><br><span class="line">    其他成员...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public enum A&#123;</span><br><span class="line">    X,Y,Z;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ol>
<li>枚举类中的第一行，只能写枚举类的对象名称，且要用逗号隔开</li>
<li>这些名称，本质是常量，每个常量都记住了枚举类的一个对象</li>
</ol>
<ul>
<li><strong>枚举类的特点</strong><br><img src="https://pic1.imgdb.cn/item/68c554d958cb8da5c8a72910.png"><br>java.lang.Enum类重写了toString方法<br><img src="https://pic1.imgdb.cn/item/68c5552d58cb8da5c8a7294e.png"><br>使得输出枚举对象时输出的是名称而不是地址</li>
</ul>
<p>拿枚举对象索引的方法：<br>调用<code>ordinal</code>方法</p>
<ul>
<li><strong>枚举类的常见应用场景</strong><br>枚举类很适合做信息分类和标志<br><img src="https://pic1.imgdb.cn/item/68c55a1d58cb8da5c8a72cbf.png"></li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p><img src="https://pic1.imgdb.cn/item/68c55b9958cb8da5c8a72dab.png"><br><img src="https://pic1.imgdb.cn/item/68c55d6158cb8da5c8a72ea9.png"></p>
<ul>
<li><strong>抽象类的注意事项、特点</strong><ol>
<li>抽象类中不一定要有抽象方法，<font color=red>有抽象方法的类必须是抽象类</font></li>
<li>类有的成员：成员变量、方法、构造器，抽象类都可以有</li>
<li><font color=red>抽象类最主要的特点：抽象类不能创建对象，仅作为一种特殊的父类，让子类继承并实现</font></li>
<li>一个类继承抽象类，必须重写完抽象类的全部抽象方法，否则这个类也必须定义成抽象类</li>
</ol>
</li>
<li><strong>使用抽象类的好处</strong><br>父类知道每个子类都要做某个行为，但每个子类要做的情况不一样，父亲就定义成抽象方法，交给子类去重写实现，<font color=red>我们设计这样的抽象类，就是为了更好的支持多态</font><br>类比c++的virtual，这样父类就不用多定义方法的内容</li>
<li><strong>模板方法设计模式</strong><br><strong>写法</strong><ol>
<li>定义一个抽象类</li>
<li>在里面定义2个方法<ol>
<li>一个是模板方法：把共同的实现步骤放里面去</li>
<li>一个是抽象方法：不确定的实现步骤，交给具体的子类来完成</li>
</ol>
</li>
</ol>
</li>
</ul>
<p><strong>建议使用final关键字修饰模板方法，为什么？</strong></p>
<ul>
<li>模板方法是给子类直接使用的，不能被子类重写</li>
<li>一旦子类重写了模板方法，模板方法就失效了</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p><strong>关键字</strong>：<code>interface</code><br>JDK 8之前，接口中只能定义常量和抽象方法</p>
<ol>
<li>常量：接口中定义常量可以省略public static final不写，默认会加上去</li>
<li>抽象方法：接口中定义抽象方法可以省略public abstract不写，默认会加上去</li>
</ol>
<ul>
<li><strong>注意</strong>：<font color=red>接口不能创建对象</font></li>
<li>接口是用来被类<font color=red>实现（implements）</font>的，实现接口的类称为<font color=red>实现类，一个类可以同时实现多个接口</font><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 实现类类名 implements 接口1，接口2，接口3，...&#123;</span><br><span class="line">    //实现类实现多个接口，必须重写完全部接口的全部抽象方法，否则实现类需要定义成抽象类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>接口的好处</strong><ul>
<li>弥补了类单继承的不足，一个类同时可以实现多个接口，使类的角色更多，功能更强大</li>
<li>让程序可以面向接口编程，这样程序员就可以灵活方便的切换各种业务实现（更利于程序的解耦合）<br><img src="https://pic1.imgdb.cn/item/68c5704558cb8da5c8a76333.png"></li>
</ul>
</li>
<li><strong>JDK8新增的三个方法，几点注意事项</strong><br><img src="https://pic1.imgdb.cn/item/68c574b258cb8da5c8a76795.png"><br><img src="https://pic1.imgdb.cn/item/68c5761d58cb8da5c8a76d94.png"><br>第三点：一般的静态方法可以通过子类类名调用，但接口的静态方法只能用当前接口名来调用<br><strong>新增方法作用</strong>：<br>增强了接口的能力，更便于项目的扩展和维护（如果接口中新增了一个方法，通过用default可以不用在每个实现类中都新增方法）</li>
<li><strong>接口的注意事项</strong><ol>
<li>接口与接口可以多继承，一个接口可以同时继承多个接口【重点】</li>
<li>一个接口继承多个接口，如果多个接口中存在方法签名冲突（一样不算冲突），则此时不支持多继承，也不支持多实现</li>
<li>一个类继承了父类，又同时实现了接口，如果父类中和接口中有同名的默认方法，实现类会优先用父类的<br>一定要调用接口方法：<br><a target="_blank" rel="noopener" href="https://imgse.com/i/pVWOIfg"><img src="https://s21.ax1x.com/2025/09/14/pVWOIfg.png" alt="pVWOIfg.png"></a><br>用一个方法中转<br><code>A2.super.show()</code></li>
</ol>
</li>
</ul>
<ol>
<li>一个类实现了多个接口，如果多个接口中存在同名的默认方法，可以不冲突，这个类重写该方法即可</li>
</ol>
<ul>
<li><p><strong>抽象类和接口的区别</strong><br>相同点：</p>
<ol>
<li>都是抽象形式，都可以有抽象方法，都不能创建对象</li>
<li>都是派生子类形式：抽象类是被子类继承使用，接口是被实现类实现</li>
<li>一个类继承抽象类，或者实现接口，都必须重写完他们的抽象方法，否则自己要成为抽象类或者报错</li>
<li>都能支持多态，都能实现解耦合</li>
</ol>
<p>  不同点：<br>  5. 抽象类中可以定义类的全部普通成员，接口只能定义常量、抽象方法（JDK8新增的三种方式）<br>  6. 抽象类只能被类单继承，接口可以被类多实现（一个类继承抽象类就不能再继承其他类，一个类实现了接口还可以继承其他类或者实现其他接口）<br>  7. 抽象类体现模板思想，更利于做父类，实现代码的复用性<br>  8. 接口更适合做功能的解耦合，解耦合性更强更灵活</p>
</li>
</ul>
<h3 id="lombok技术"><a href="#lombok技术" class="headerlink" title="lombok技术"></a>lombok技术</h3><p>lombok技术可以实现为类自动添加getter setter方法、无参数构造器、toString方法等<br><strong>方法</strong>：</p>
<ol>
<li>类前写上<code>@Data</code></li>
<li>光标移到上面，按alt+enter</li>
<li>Add’lombok’to classpath（别的公司写的框架，需要联网）</li>
</ol>
<p>默认提供无参构造器<br>若要提供有参构造器，需加<code>@AllArgsConstructor</code><br>但是有参构造器写了无参构造器就没了<br>因此需再写上<code>@NoArgsConstructor</code><br><code>@Data</code>能够重写toString方法，输出对象时输出对象全部信息</p>
<blockquote>
<p>注意：要打开启用注解处理，否则报错</p>
</blockquote>
<h2 id="day6"><a href="#day6" class="headerlink" title="day6"></a>day6</h2><h3 id="类中的成分-代码块"><a href="#类中的成分-代码块" class="headerlink" title="类中的成分-代码块"></a>类中的成分-代码块</h3><p>代码块是类的5大成分之一（成员变量、构造器、方法、代码块、内部类）<br><strong>代码块分为两种</strong></p>
<ul>
<li><strong>静态代码块</strong><ul>
<li><strong>格式</strong>：static{}</li>
<li><strong>特点</strong>：类加载时自动执行（与类一起优先加载），由于类只会加载一次，所以静态代码块也只会执行一次</li>
<li><strong>作用</strong>：完成类的初始化，例如：对静态变量的初始化赋值</li>
</ul>
</li>
<li><strong>实例代码块</strong><ul>
<li><strong>格式</strong>：{}</li>
<li><strong>特点</strong>：每次创建对象时，执行实例代码块，并在构造器前执行</li>
<li><strong>作用</strong>：和构造器一样，都是用来完成对象的初始化的，例如：对实例变量进行初始化赋值</li>
</ul>
</li>
</ul>
<h3 id="类中的成分-内部类"><a href="#类中的成分-内部类" class="headerlink" title="类中的成分-内部类"></a>类中的成分-内部类</h3><p><img src="https://pic1.imgdb.cn/item/68c67bc1c5157e1a8800c199.png"></p>
<ul>
<li><p><strong>成员内部类</strong><br><img src="https://pic1.imgdb.cn/item/68c67e49c5157e1a8800ce37.png"><br><img src="https://pic1.imgdb.cn/item/68c67e72c5157e1a8800cf65.png"></p>
</li>
<li><p><strong>静态内部类</strong><br><img src="https://pic1.imgdb.cn/item/68c79f61c5157e1a88040c64.png"><br><img src="https://pic1.imgdb.cn/item/68c79f75c5157e1a88040ca3.png"><br>静态内部类中<strong>可以</strong>直接访问外部类中的<strong>静态成员</strong>，<strong>不可以</strong>直接访问外部类的<strong>实例成员</strong><br>原因：实例成员是属于外部类的对象的，而静态内部类不属于外部类的对象（成员内部类属于外部类的对象）<br><strong>定义成员内部类还是静态外部类？</strong><br>都可以</p>
</li>
<li><p><strong>局部内部类（了解）</strong><br><img src="https://pic1.imgdb.cn/item/68c7a173c5157e1a88040e72.png"></p>
</li>
<li><p><strong>匿名内部类（最重要）</strong><br><strong>是一种特殊的局部内部类</strong><br><strong>所谓匿名：指的是程序员不需要为这个类声明名字，默认有个隐藏的名字</strong></p>
<ul>
<li><strong>特点</strong>：匿名内部类本质就是一个子类，并会立即创建出一个子类对象</li>
<li><strong>作用</strong>：用于更方便的创建一个子类对象</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new 类或接口（参数值...）&#123;</span><br><span class="line">    类体（一般是方法重写）;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Animal()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void cry()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>  <img src="https://pic1.imgdb.cn/item/68c7a5fac5157e1a880419ec.png"><br>  <img src="https://pic1.imgdb.cn/item/68c7a624c5157e1a88041b5c.png"></p>
<hr>
<p>  <strong>匿名内部类在开发中的常见形式</strong><br>  通常作为一个对象参数传输给方法<br>  <img src="https://pic1.imgdb.cn/item/68c7a881c5157e1a88042de1.png"><br>  对象回调思想</p>
<hr>
<p>  <strong>匿名内部类在开发中的真实使用场景实例</strong><br>  一、<br>  <img src="https://pic1.imgdb.cn/item/68c7ae00c5157e1a8804592e.png"><br>  二、<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//需求：按照年龄升序排序。可以调用sun公司写好的API直接对数组进行排序</span><br><span class="line">//public static void sort(T[] a,Comparator&lt;T&gt; c)</span><br><span class="line">//      参数一：需要排序的数组</span><br><span class="line">//      参数二：需要给sort声明一个Comparator比较器对象（指定排序的规则）</span><br><span class="line">//  sort方法内部会调用匿名内部类对象的compare方法，对数组中的学生对象进行两两比较，从而实现排序</span><br><span class="line">Arrays.sort(students,new Comparator&lt;Student&gt;()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Student o1,Student o2)&#123;</span><br><span class="line">        //指定排序规则：</span><br><span class="line">        //如果你认为左边对象  大于  右边对象  那么返回正整数</span><br><span class="line">        //如果你认为左边对象  小于  右边对象  那么返回负整数</span><br><span class="line">        //如果两边相等那么返回0</span><br><span class="line">        if(o1.getAge()&gt;o2.getAge())&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;else if(o1.getAge()&lt;o2.getAge())&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">        return o1.getAge()-o2.getAge();//按照年龄升序</span><br><span class="line">        return o2.getAge()-o1.getAge();//按照年龄降序</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
</li>
</ul>
<h2 id="day7"><a href="#day7" class="headerlink" title="day7"></a>day7</h2><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><h4 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h4><p>此“函数”类似于数学中的函数（强调做什么），只要输入的数据一致返回的结果也是一&#x3D;一致的<br><code>Java中的函数（Lambda表达式）：(x)-&gt;2x+1</code><br><strong>函数式编程解决了什么问题？</strong><br>使用lambda函数替代某些匿名内部类对象，从而让程序代码更简洁，可读性更好</p>
<ul>
<li><strong>Lambda表达式</strong><br>JDK 8开始新增的一种语法形式，它表示函数<br>可以<font color=red>用于替代某些匿名内部类对象，从而让程序更简洁，可读性更好</font><blockquote>
<p>注意：lambda表达式只能替代函数式接口的匿名内部类</p>
</blockquote>
  <strong>什么是函数式接口</strong><br>  有且仅有一个抽象方法的接口<br>  <code>@FunctionalInterface//声明函数式接口的注解，约束当前接口必须是函数式接口（可加可不加）</code><br>  <strong>Lambda表达式示例</strong>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class LambdaDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Swim s1=() -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;学生游泳很快&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">    s1.swimming();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//函数式接口：只有一个抽象方法的接口</span><br><span class="line">@FunctionalInterface//声明函数式接口的注解</span><br><span class="line">interface Swim&#123;</span><br><span class="line">    void swimming();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  Lambda表达式原理：可根据上下文推断出原本应为的匿名内部类</li>
<li><strong>Lambda的省略规则</strong><br><strong>作用</strong>：用于进一步简化Lambda表达式的写法<br><strong>具体规则</strong><ol>
<li>参数类型可以全部省略不写</li>
<li>如果只有一个参数，参数类型省略的同时”()”也可以省略，但多个参数不能省略”()”</li>
<li>如果Lambda表达式中只有一行代码，大括号可以不写，同时要省略分号”;”。如果这行代码是return语句，也必须去掉return</li>
</ol>
</li>
</ul>
<h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><ul>
<li><strong>静态方法引用</strong><br><font color=red>类名::静态方法</font><br><strong>使用场景</strong><br>如果某个Lambda表达式里只是调用一个静态方法，并且”-&gt;”前后参数的形式一致，就可以使用静态方法引用<br><img src="https://pic1.imgdb.cn/item/68c7ce7ec5157e1a88060108.png"></li>
<li><strong>实例方法引用</strong><br><font color=red>对象名::实例方法</font><br><strong>使用场景</strong><br>如果某个Lambda表达式里只是通过对象名称调用一个实例方法，并且”-&gt;”前后参数的形式一致，就可以使用实例方法引用<br><img src="https://pic1.imgdb.cn/item/68c7de23c5157e1a8806f8dc.png"><br><img src="https://pic1.imgdb.cn/item/68c7de4dc5157e1a8806fab3.png"><blockquote>
<p>Double.compare()能够比较double类型大小，返回-1、0、1</p>
</blockquote>
</li>
<li><strong>特定类型的方法引用</strong><br><font color=red>特定类的名称::方法</font><br><strong>使用场景</strong><br>如果某个Lambda表达式里只是调用一个特定类型的实例方法，并且前面参数列表中的第一个参数是作为方法的主调，后面的所有参数都是作为该实例方法的入参的，则此时就可以使用特定类型的方法引用</li>
<li><strong>构造器引用</strong><br><font color=red>类名::new</font><br><strong>使用场景</strong><br>如果某个Lambda表达式里只是在创建对象，并且”-&gt;”前后参数情况一致，就可以使用构造器引用</li>
</ul>
<h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><ul>
<li><p><strong>String</strong><br><strong>String创建字符串对象的方式</strong><br><img src="https://pic1.imgdb.cn/item/68c7f4dbc5157e1a88077a60.png"><br><strong>String创建对象的区别</strong></p>
<ul>
<li>只要是以”…”方式写出的字符串对象，会存储到字符串<strong>常量池</strong>，且相同内容的字符串只存储一份</li>
<li>通过new方式创建字符串对象，每new一次都会产生一个新的对象放在<strong>堆内存</strong>中</li>
</ul>
<p>  <img src="https://pic1.imgdb.cn/item/68c7f560c5157e1a88077cb7.png"><br>  <img src="https://pic1.imgdb.cn/item/68c7f58ac5157e1a88077d7a.png"><br>  <strong>String提供的常用方法</strong><br>  <img src="https://pic1.imgdb.cn/item/68c7fde2c5157e1a88079c9e.png"><br>  <strong>equals</strong>最重要，不能直接“&#x3D;&#x3D;”，因为比较的是地址<br>  <strong>案例：用String开发验证码</strong><br>  <img src="https://pic1.imgdb.cn/item/68c7fd80c5157e1a88079b21.png"></p>
</li>
<li><p><strong>ArrayList</strong><br>集合是一种容器，用来装数据的，类似于数组（ArrayList类似于c++的vector）<br><img src="https://pic1.imgdb.cn/item/68c8001fc5157e1a8807a31d.png"><br><strong>实例</strong><br><img src="https://pic1.imgdb.cn/item/68c80057c5157e1a8807a3d8.png"><br><img src="https://pic1.imgdb.cn/item/68c8006dc5157e1a8807a411.png"></p>
</li>
</ul>
<h2 id="day8"><a href="#day8" class="headerlink" title="day8"></a>day8</h2><h3 id="GUI界面编程"><a href="#GUI界面编程" class="headerlink" title="GUI界面编程"></a>GUI界面编程</h3><p>GUI，全称Graphical User Interface,是指图形用户界面</p>
<ul>
<li><p><strong>Java的GUI编程包</strong></p>
<ul>
<li><strong>AWT</strong>(Abstract Window Toolkit)<br>  提供了一组原生的GUI组件，依赖于操作系统的本地窗口系统</li>
<li><strong>Swing</strong><br>  基于AWT，提供了更丰富的GUI组件，轻量级组件，不依赖于本地窗口系统</li>
</ul>
</li>
<li><p><strong>常用的Swing组件</strong></p>
<ul>
<li>JFrame：窗口</li>
<li>JPanel：用于组织其他组件的容器</li>
<li>JButton：按钮组件</li>
<li>JTextField：输入框</li>
<li>JTable：表格</li>
</ul>
</li>
<li><p><strong>常见的布局管理器（了解）（Layout Manager）</strong><br>决定组件在容器中的布局方式，避免了手动设置每个组件的位置和大小，从而简化了GUI设计过程</p>
<ul>
<li><strong>FlowLayout</strong><br>  <img src="https://pic1.imgdb.cn/item/68ca2b85c5157e1a88103040.png"></li>
<li><strong>BorderLayout</strong><br>  <img src="https://pic1.imgdb.cn/item/68ca2bb5c5157e1a88103208.png"></li>
<li><strong>GridLayout</strong><br>  <img src="https://pic1.imgdb.cn/item/68ca2d60c5157e1a88104301.png"></li>
<li><strong>BoxLayout</strong><br>  <img src="https://pic1.imgdb.cn/item/68ca2d8cc5157e1a8810449d.png"></li>
</ul>
</li>
<li><p><strong>常用的事件监听器对象</strong></p>
<ul>
<li><strong>点击事件监听器</strong><br>  <img src="https://pic1.imgdb.cn/item/68ca3107c5157e1a881054c7.png"></li>
<li><strong>按键事件监听器</strong><br>  <img src="https://pic1.imgdb.cn/item/68ca30e5c5157e1a881053dc.png"><br>  窗口上盖了一层面板，面板上又有按钮，因此按钮是焦点，要控制窗口就要让窗口再次成为焦点，但点击按钮后按钮又重新成为焦点</li>
</ul>
</li>
<li><p><strong>事件的几种常见写法</strong></p>
</li>
</ul>
<ol>
<li>直接提供实现类，用于创建事件监听对象</li>
<li>直接使用匿名内部类的对象，代表事件监听对象</li>
<li>自定义窗口，让窗口对象实现事件接口<br><strong>自定义窗口（高级）</strong><br><img src="https://pic1.imgdb.cn/item/68ca360cc5157e1a88106e86.png"><br><img src="https://pic1.imgdb.cn/item/68ca3636c5157e1a88106ea5.png"></li>
</ol>
<h2 id="day9"><a href="#day9" class="headerlink" title="day9"></a>day9</h2><h3 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h3><p>一般会创建一个app类来运行<br>shift+f6可以同步更改变量名</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul>
<li><strong>Java的异常体系</strong><br><img src="https://pic1.imgdb.cn/item/68cd0ed0c5157e1a881ba433.png"></li>
<li><strong>异常的作用</strong><br><img src="https://pic1.imgdb.cn/item/68cd165bc5157e1a881bde5c.png"><br><img src="https://pic1.imgdb.cn/item/68d8ee96c5157e1a88405fb0.png"></li>
<li><strong>自定义异常</strong><br><img src="https://pic1.imgdb.cn/item/68cd3cfac5157e1a881d130a.png"><br><img src="https://pic1.imgdb.cn/item/68d8ef48c5157e1a884060bd.png"><br><img src="https://pic1.imgdb.cn/item/68d8ef5cc5157e1a884060dd.png"><br>Sun公司已经在摒弃编译时异常了，最好定义运行时异常</li>
</ul>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>定义类、接口、方法时，<font color=red>同时声明了一个或者多个类型变量（如：<E>）</font><br>称为泛型类、泛型接口、泛型方法，它们统称为泛型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color=red>作用</font>：泛型提供了在编译阶段约束所能操作的数据类型，并自动进行检查的能力！这样可以避免强制类型转换，及其可能出现的异常<br><font color=red>泛型的本质</font>：把具体的数据类型作为参数传给类型变量<br><img src="https://pic1.imgdb.cn/item/68cf879cc5157e1a88210fa9.png"></p>
<ul>
<li><p><strong>泛型类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 类名&lt;类型变量，类型变量，...&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt;&#123;</span><br><span class="line"> ...   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：类型变量建议用大写的英文字母，常用的有：<font color=red>E(Element)、T(Type)、K(Key)、V(Value)</font><br>等</p>
</li>
<li><p><strong>泛型接口</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 interface 接口名&lt;类型变量，类型变量，...&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface A&lt;E&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：类型变量建议用大写的英文字母，常用的有：<font color=red>E(Element)、T(Type)、K(Key)、V(Value)</font><br>等</p>
</li>
<li><p><strong>泛型方法-通配符-上下限</strong></p>
<ul>
<li><strong>泛型方法</strong>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符&lt;类型变量，类型变量，...&gt;返回值类型 方法名（形参列表）&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; void test(T t)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>通配符</strong><br>  就是“?”，可以在“使用泛型”的时候代表一切类型；E T K V是在定义泛型的时候使用</li>
<li><strong>泛型的上下限</strong><ul>
<li><strong>泛型上限</strong>：<code>？ extends Car</code>：？能接收的必须是Car或者其子类</li>
<li><strong>泛型下限</strong>：<code>？ super Car</code>：？能接收的必须是Car或者其父类</li>
</ul>
</li>
</ul>
<p>  <img src="https://pic1.imgdb.cn/item/68cf9589c5157e1a8821196d.png"><br>  有了上下限之后狗就进不来了</p>
</li>
<li><p><strong>泛型支持的类型-包装类</strong></p>
<ul>
<li><strong>泛型支持的类型</strong><br>  泛型不支持基本数据类型，只能支持对象类型（引用数据类型）<br>  <img src="https://pic1.imgdb.cn/item/68cf9790c5157e1a88212a5a.png"><br>  泛型擦除：泛型工作在编译阶段，等编译后泛型就没用了，所以泛型在编译后都会被擦除。所有类型会恢复成Object类型</li>
<li><strong>包装类</strong><br>  包装类就是把基本类型的数据包装成对象的类型<br>  <img src="https://pic1.imgdb.cn/item/68cf98a1c5157e1a8821322a.png"><br>  用第二个原因：valueOf方法提前缓存了一个数组来存[-128,127]的整数，在此范围内都是同一个对象<br>  <img src="https://pic1.imgdb.cn/item/68cf9b05c5157e1a882140a4.png"><br>  <strong>自动装箱</strong>：基本数据类型可以自动转换为包装类型<br>  <strong>自动拆箱</strong>：包装类型可以自动转换为基本数据类型<br>  <img src="https://pic1.imgdb.cn/item/68cf9ae3c5157e1a88214079.png"><br>  <strong>包装类具备的其他功能</strong><br>  <img src="https://pic1.imgdb.cn/item/68cf9d95c5157e1a8821562b.png"><br>  <img src="https://pic1.imgdb.cn/item/68cf9d66c5157e1a882154c4.png"></li>
</ul>
</li>
</ul>
<h2 id="day10"><a href="#day10" class="headerlink" title="day10"></a>day10</h2><p><img src="https://pic1.imgdb.cn/item/68cf9f67c5157e1a882163ec.png"></p>
<h3 id="Collection集合"><a href="#Collection集合" class="headerlink" title="Collection集合"></a>Collection集合</h3><p><img src="https://pic1.imgdb.cn/item/68cfa9dac5157e1a8821878e.png"><br><img src="https://pic1.imgdb.cn/item/68cfaa02c5157e1a882188d9.png"></p>
<ul>
<li><p><strong>Collection的常用功能</strong><br><img src="https://pic1.imgdb.cn/item/68cfaa26c5157e1a88218aba.png"><br><img src="https://pic1.imgdb.cn/item/68cfadd1c5157e1a8821a697.png"><br><img src="https://pic1.imgdb.cn/item/68cfadf9c5157e1a8821a853.png"></p>
</li>
<li><p><strong>Collection的遍历</strong></p>
<ol>
<li>迭代器遍历<br>  <img src="https://pic1.imgdb.cn/item/68cfaeddc5157e1a8821ac39.png"><br>  <img src="https://pic1.imgdb.cn/item/68cfb1a8c5157e1a8821adc1.png"><br>  <code>next()</code>是先取元素再移位，<code>hasNext()</code>是判断当前位置有没有元素<br>  <code>.iterator()</code>实际上返回的是Iterator接口的实现类对象</li>
<li>增强for循环  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(元素的数据类型 变量名 ： 数组或者集合)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;Stirng&gt; c = new ArrayList&lt;&gt;();</span><br><span class="line">...</span><br><span class="line">for(String s : c)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Lambda表达式<br>  需要使用Collection的forEach方法来完成<br>  <img src="https://pic1.imgdb.cn/item/68cfba17c5157e1a8821ba90.png"><br>  简化：<br>  <img src="https://pic1.imgdb.cn/item/68cfba92c5157e1a8821bdf7.png"></li>
</ol>
</li>
<li><p><strong>三种遍历方式的区别</strong><br><strong>认识并发修改异常问题</strong><br><img src="https://pic1.imgdb.cn/item/68cfc3d4c5157e1a8821f95b.png"></p>
</li>
<li><p><strong>for循环解决</strong><br>直接删出现并发修改异常问题<br><img src="https://pic1.imgdb.cn/item/68cfc420c5157e1a8821f9ae.png"><br>原因：删除后后一位顶替被删除元素，但是同时i++，导致删不完全</p>
<ul>
<li><strong>解决方案1</strong>：删除数据后做一步i–操作<br>  <img src="https://pic1.imgdb.cn/item/68cfc48fc5157e1a8821fa17.png"></li>
<li><strong>解决方案2</strong>：倒着遍历并删除（前提是支持索引）<br>  <img src="https://pic1.imgdb.cn/item/68cfc4d2c5157e1a8821fa55.png"></li>
</ul>
</li>
<li><p><strong>迭代器解决</strong><br><strong>方案</strong>：迭代器遍历并删除（使用迭代器自己的方法来删除）<br><img src="https://pic1.imgdb.cn/item/68cfc53bc5157e1a8821faa0.png"></p>
<blockquote>
<p>用增强for还有lambda都没有办法解决并发修改异常问题<br>原因：Collection自带的next()方法会调用检查修改的方法，比对已修改值和期待修改值</p>
</blockquote>
</li>
</ul>
<p><img src="https://pic1.imgdb.cn/item/68cfc63ec5157e1a8821fb6a.png"></p>
<h4 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h4><ul>
<li><strong>List集合的特有方法</strong><br><img src="https://pic1.imgdb.cn/item/68cfc78bc5157e1a8821fbf0.png"></li>
<li><strong>ArrayList和LinkedList的区别</strong><br>底层采用的<strong>数据结构</strong>不同，应用场景不同<br>ArrayList底层是基于<strong>数组</strong>存储数据的（查询速度快、增删数据效率低）<br>LinkedList底层是基于<strong>链表</strong>存储数据的（查询慢，链表增删相对快）<ul>
<li><strong>ArrayList</strong><br>  最开始数组容量为0，第一次扩容为10，第二次扩容为15（1.5倍）</li>
<li><strong>LinkedList</strong><br>  基于双链表实现的（对首尾元素进行增删改查的速度是极快的）——&gt;LinkedList新增了很多首尾操作的特有方法<br>  <img src="https://pic1.imgdb.cn/item/68d13b43c5157e1a88277f5e.png"><br>  可以用LinkedList来设计队列、栈</li>
</ul>
</li>
</ul>
<h4 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h4><p>Set要用到的常用方法，基本上就是Collection提供的。自己几乎没有额外新增一些常用功能</p>
<ul>
<li><p><strong>HashSet</strong><br><img src="https://pic1.imgdb.cn/item/68d1457ec5157e1a88279288.png"><br>当元素个数&#x3D;数组长度*0.75时对哈希表进行扩容两倍处理<br><font color=red>JDK8开始，当链表长度超过8</font>，且<font color=red>数组长度&gt;&#x3D;64时</font>，<font color=red>自动将链表转成红黑树，进一步提高了操作数据的性能</font></p>
<ul>
<li><strong>自定义对象去重复</strong><br>  <img src="https://pic1.imgdb.cn/item/68d148c5c5157e1a8827953f.png"><br>  否则由于不同对象存储的位置不一样，系统不会认为这些对象是重复的<br>  <strong>方法</strong>：右键，Generate，选中equals() and HashCode，重写这两个方法（equals()没有重写的话本质上是比较两个对象的内存地址）</li>
</ul>
</li>
<li><p><strong>LinkedHashSet</strong><br>依然是基于哈希表实现的<br><strong>但是，它的每个元素都额外多了一个双链表的机制记录它前后元素的位置</strong></p>
</li>
<li><p><strong>TreeSet</strong><br><strong>底层是基于红黑树实现的排序</strong><br><font color=red>注意：</font></p>
<ol>
<li>对于数值类型：Integer，Double，默认按照数值本身的大小进行升序排序</li>
<li>对于字符串类型：默认按照首字符的编号升序排序</li>
<li><font color=red>对于自定义类型如Student对象，TreeSet默认是无法直接排序的</font></li>
</ol>
</li>
<li><p><strong>自定义排序规则</strong><br><img src="https://pic1.imgdb.cn/item/68d158f5c5157e1a8827a141.png"><br><img src="https://pic1.imgdb.cn/item/68d1593dc5157e1a8827a18a.png"></p>
</li>
</ul>
<h3 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h3><h2 id="需要存储一一对应的数据时，就可以考虑使用Map集合来做-Map集合的体系特点-Map集合的常用方法-Map集合的遍历方式-1-键找值-2-键值对-3-Lambda表达式"><a href="#需要存储一一对应的数据时，就可以考虑使用Map集合来做-Map集合的体系特点-Map集合的常用方法-Map集合的遍历方式-1-键找值-2-键值对-3-Lambda表达式" class="headerlink" title="需要存储一一对应的数据时，就可以考虑使用Map集合来做- Map集合的体系特点- Map集合的常用方法- Map集合的遍历方式    1. 键找值        2. 键值对        3. Lambda表达式    "></a><strong>需要存储一一对应的数据时</strong>，就可以考虑使用Map集合来做<br>- <strong>Map集合的体系特点</strong><br><img src="https://pic1.imgdb.cn/item/68d15b0ec5157e1a8827a350.png"><br><img src="https://pic1.imgdb.cn/item/68d15ef3c5157e1a8827adf6.png"><br>- <strong>Map集合的常用方法</strong><br><img src="https://pic1.imgdb.cn/item/68d22597c5157e1a8829e3ef.png"><br>- <strong>Map集合的遍历方式</strong><br>    1. 键找值<br>    <img src="https://pic1.imgdb.cn/item/68d227eac5157e1a8829fcc9.png"><br>    2. 键值对<br>    <img src="https://pic1.imgdb.cn/item/68d2353ac5157e1a882a6b0b.png"><br>    3. Lambda表达式<br>    <img src="https://pic1.imgdb.cn/item/68d23debc5157e1a882ae46a.png"></h2><p><strong>案例</strong><br><img src="https://pic1.imgdb.cn/item/68d24a07c5157e1a882b388b.png"><br><img src="https://pic1.imgdb.cn/item/68d24a41c5157e1a882b3a00.png"><br><img src="https://pic1.imgdb.cn/item/68d24a5ec5157e1a882b3abd.png"></p>
<hr>
<ul>
<li><strong>Map集合的实现类</strong><ul>
<li><strong>HashMap集合的底层原理</strong><br>  <font color=red>实际上，原来学的Set系列集合的底层就是基于Map实现的，只是Set集合中的元素只要键数据，不要值数据而已</font><br>  HashMap跟HashSet的底层原理是一模一样的，都是基于哈希表实现的</li>
<li><strong>LinkedHashMap的底层原理</strong><br>  底层数据结构依然是基于哈希表实现的，只是每个键值对元素又额外的多了一个双链表的机制记录元素顺序（<font color=red>保证有序</font>）</li>
<li><strong>LinkedHashMap的底层原理</strong><br>  <font color=red>只能对键排序</font></li>
</ul>
</li>
</ul>
<h2 id="day11"><a href="#day11" class="headerlink" title="day11"></a>day11</h2><h3 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h3><p>Stream流是jdk8开始新增的一套API（java.util.stream.*），<font color=red>可以用于操作集合或者数组的数据</font><br>优势：<font color=red>Stream流大量的结合了Lambda的语法风格来编程</font>，功能强大，性能高效，<font color=red>代码简洁，可读性好</font><br><img src="https://pic1.imgdb.cn/item/68d2542fc5157e1a882b743b.png"><br><img src="https://pic1.imgdb.cn/item/68d25451c5157e1a882b7539.png"></p>
<ul>
<li><p><strong>Stream流的使用步骤</strong><br><img src="https://pic1.imgdb.cn/item/68d2548bc5157e1a882b76da.png"></p>
<ul>
<li><strong>获取Stream流</strong><br>  <img src="https://pic1.imgdb.cn/item/68d2582fc5157e1a882b8cd6.png"><br>  <img src="https://pic1.imgdb.cn/item/68d25851c5157e1a882b8cf1.png"><br>  Stream.of()的参数可以为一个、多个、数组甚至没有</li>
<li><strong>常用中间方法</strong><br>  <img src="https://pic1.imgdb.cn/item/68d26633c5157e1a882b93fd.png"></li>
<li><strong>常用终结方法</strong><br>  <img src="https://pic1.imgdb.cn/item/68d270bac5157e1a882b994f.png"><br>  <img src="https://pic1.imgdb.cn/item/68d27088c5157e1a882b9944.png"></li>
<li><strong>收集Stream流</strong><br>  <img src="https://pic1.imgdb.cn/item/68d273a4c5157e1a882b9a7a.png"><br>  <img src="https://pic1.imgdb.cn/item/68d273fbc5157e1a882b9a9d.png"><br>  <img src="https://pic1.imgdb.cn/item/68d27426c5157e1a882b9ae0.png"><blockquote>
<p>set.addAll(arrayList)可以把ArrayList变成Set</p>
</blockquote>
</li>
</ul>
<p>  Collectors.toList()方法返回的是一个ArrayList，Stream流对象通过collect方法把数据传到ArrayList中<br>  用了特殊类型的方法引用简化</p>
</li>
</ul>
<hr>
<p><strong>案例：做牌</strong></p>
<ul>
<li><p><strong>方法中可变参数</strong><br>就是一种特殊形参，定义在方法、构造器的形参列表里，格式是：<font color=red>数据类型…参数名称；</font><br><strong>可变参数的特点和好处</strong><br>特点：可以不传数据给它；可以传一个或者同时传多个数据给它；也可以传一个数组给它<br>好处：常常用来灵活的接收数据</p>
</li>
<li><p><strong>注意事项</strong>：</p>
<ol>
<li><strong>可变参数在方法内部就是一个数组</strong></li>
<li>可变参数在形参列表中只能有一个参列表的最后面</li>
<li>可变参数在形参列表的最后面</li>
</ol>
<p>  <img src="https://pic1.imgdb.cn/item/68d28bfdc5157e1a882ba8f0.png"></p>
</li>
<li><p><strong>Collections工具类</strong><br><img src="https://pic1.imgdb.cn/item/68d28d2dc5157e1a882baf50.png"><br><img src="https://pic1.imgdb.cn/item/68d28e71c5157e1a882bb032.png"></p>
</li>
</ul>
<h2 id="day12"><a href="#day12" class="headerlink" title="day12"></a>day12</h2><h3 id="File-IO流"><a href="#File-IO流" class="headerlink" title="File-IO流"></a>File-IO流</h3><ul>
<li><strong>File</strong><br>File是java.io.包下的类，File类的对象，用于代表当前操作系统的文件（可以是<font color=red>文件、或文件夹</font>）<blockquote>
<p>File类只能对文件本身进行操作，<strong>不能读写文件里面存储的数据</strong></p>
</blockquote>
</li>
<li><strong>IO流</strong><br>用于<strong>读写数据</strong>的</li>
</ul>
<h4 id="File"><a href="#File" class="headerlink" title="File"></a>File</h4><ul>
<li><p><strong>创建File类的对象</strong><br><img src="https://pic1.imgdb.cn/item/68d8f233c5157e1a88406e7d.png"></p>
<blockquote>
<p>File封装的对象仅仅是一个路径名，这个路径可以是存在的，也允许是不存在的</p>
</blockquote>
</li>
<li><p><strong>Flie提供的判断文件类型、获取文件信息功能</strong><br><img src="https://pic1.imgdb.cn/item/68d8f87ec5157e1a884090c2.png"></p>
</li>
<li><p><strong>File提供的创建和删除文件的方法</strong><br><img src="https://pic1.imgdb.cn/item/68d8fca1c5157e1a8840a59f.png"></p>
</li>
<li><p><strong>File提供的遍历文件夹的方法</strong><br><img src="https://pic1.imgdb.cn/item/68d8fcc7c5157e1a8840a64e.png"></p>
<blockquote>
<p>注意：只能一级</p>
</blockquote>
<p>  <img src="https://pic1.imgdb.cn/item/68d8fe14c5157e1a8840aa21.png"></p>
</li>
</ul>
<h4 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h4><p>ASCII码使用<strong>一个字节</strong>存储一个字符，首位都是0（有效位为7位，可存储128个字符）</p>
<ul>
<li><font color=red>GBK</font>（汉字内码扩展规范，国标）<br>汉字编码字符集，包含了2万多个汉字等字符，<font color=red>GBK中一个中文字符编码成两个字节的形式存储</font><blockquote>
<p>注意：GBK兼容ASCII字符集</p>
</blockquote>
  GBK规定：汉字的第一个字节的第一位必须是1（确保能正确读取）</li>
<li><strong>Unicode字符集</strong>（统一码，也叫万国码）<br>Unicode是国际组织制定的，可以容纳世界上所有文字、符号的字符集<ul>
<li>UTF-32<br>  4个字节表示一个字符（占存储空间，通信效率变低）</li>
<li><strong>UTF-8字符集</strong><br>  是Unicode字符集的一种编码方案，采取可变长编码方案，共分四个长度区：1个字节，2个字节，3个字节，4个字节<br>  <font color=red>英文字符、数字等只占1个字节（兼容标准ASCII编码），汉字字符占用3个字节</font><br>  <img src="https://pic1.imgdb.cn/item/68d90ac0c5157e1a8840b885.png"><blockquote>
<p>注意1：字符编码时使用的字符集，和解码时使用的字符集必须一致，<font color=red>否则会出现乱码</font><br>注意2：英文，数字一般不会乱码，因为很多字符集都兼容了ASCII编码</p>
</blockquote>
</li>
</ul>
</li>
<li><strong>使用程序对字符进行编码和解码操作</strong><br><img src="https://pic1.imgdb.cn/item/68d92a80c5157e1a8840d4a9.png"></li>
</ul>
<h4 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h4><ul>
<li><strong>IO流的分类</strong><br><img src="https://pic1.imgdb.cn/item/68d92b73c5157e1a8840d615.png"><br>InputStream、OutputStream、Reader、Writer（抽象类）<br>FileInputStream、FileOutputStream、FileReader、FileWriter（实现类）<ul>
<li><strong>FlieInputStream（文件字节输入流）</strong><br><strong>作用</strong>：以内存为基准，可以把磁盘文件中的数据以字节的形式读入到内存中去<br><img src="https://pic1.imgdb.cn/item/68d92c98c5157e1a8840d7c4.png"><br><img src="https://pic1.imgdb.cn/item/68d93ae7c5157e1a8840ee7b.png"><br><img src="https://pic1.imgdb.cn/item/68d93b54c5157e1a8840ef31.png"><ul>
<li><strong>一次性读取完全部字节</strong><br>  <img src="https://pic1.imgdb.cn/item/68d93b67c5157e1a8840ef52.png"><br>  <img src="https://pic1.imgdb.cn/item/68d93bb1c5157e1a8840efde.png"></li>
</ul>
</li>
<li><strong>FileOutputStream（文件字节输出流）</strong><br><img src="https://pic1.imgdb.cn/item/68d93c1cc5157e1a8840f072.png"><br><img src="https://pic1.imgdb.cn/item/68d93eafc5157e1a8840f542.png"><br><code>\r\n</code>兼容性比<code>\n</code>更好<blockquote>
<p>注意：IO流对象创建完后一定要关闭</p>
</blockquote>
</li>
<li><strong>字节流做复制</strong><br><img src="https://pic1.imgdb.cn/item/68d940fcc5157e1a8840fa9e.png"></li>
<li><strong>资源释放问题</strong><ul>
<li>方案一<br><img src="https://pic1.imgdb.cn/item/68d94351c5157e1a8841000e.png"><br><img src="https://pic1.imgdb.cn/item/68d943a2c5157e1a8841004c.png"><br>首先fis和fis先定义成null，再在try里面new出来，finally里面加条件判断<code>if ... !=null</code>，然后再分别try-catch</li>
<li><strong>方案二（try-with-resource）</strong><br><img src="https://pic1.imgdb.cn/item/68d94756c5157e1a8841066c.png"><br><img src="https://pic1.imgdb.cn/item/68d946f4c5157e1a88410599.png"></li>
</ul>
</li>
<li><strong>FileReader（文件字符输入流）</strong><br><img src="https://pic1.imgdb.cn/item/68d94fa0c5157e1a88411262.png"><br><img src="https://pic1.imgdb.cn/item/68d94f84c5157e1a8841122e.png"></li>
<li><strong>FileWriter（文件字符输出流）</strong><br><img src="https://pic1.imgdb.cn/item/68d950d2c5157e1a884113d5.png"><blockquote>
<p>字符输出流写出数据后，必须刷新流，或者关闭流，写出去的数据才能生效 .flush()，刷新后，流可以继续使用（关闭包含了刷新）</p>
</blockquote>
</li>
<li><strong>缓冲流</strong><ul>
<li><strong>BufferedInputStream缓冲字节输入流</strong><br><font color=red>作用：可以提高字节输入流读取数据的性能</font><br><img src="https://pic1.imgdb.cn/item/68d95564c5157e1a88411e47.png"><br><img src="https://pic1.imgdb.cn/item/68d9557cc5157e1a88411e71.png"></li>
<li><strong>缓冲字符输入流</strong><br><img src="https://pic1.imgdb.cn/item/68d9580ac5157e1a88412355.png"><br><img src="https://pic1.imgdb.cn/item/68d958eec5157e1a884124f4.png"></li>
<li><strong>缓冲字符输出流</strong><br><img src="https://pic1.imgdb.cn/item/68d9593cc5157e1a88412590.png"></li>
<li><strong>性能分析（重点）</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>其他流</strong><ul>
<li><strong>字符输入转换流（InputStreamReader）（继承Reader）</strong><br>  解决不同编码时，字符流读取文本内容乱码的问题<br>  <font color=red>解决思路：先获取文件的原始字节流，再将其按真实的字符集编码转成字符输入流，这样字符输入流中的字符就不乱码了</font><br>  <img src="https://pic1.imgdb.cn/item/68da69aac5157e1a8845b9d1.png"><br>  <img src="https://pic1.imgdb.cn/item/68da6a89c5157e1a8845bf8d.png"></li>
<li><strong>打印流（PrintStream&#x2F;PrintWriter）</strong><br><img src="https://pic1.imgdb.cn/item/68da6acdc5157e1a8845c149.png"><br><font color=red>作用：打印流可以实现更方便、更高效的打印数据出去，能实现打印啥出去就是啥出去</font><br><img src="https://pic1.imgdb.cn/item/68da6c73c5157e1a8845c4f8.png"></li>
<li><strong>特殊数据流</strong><ul>
<li><strong>DataOutputStream（数据输出流）</strong><br>允许把数据和其类型一并写出去</li>
<li><strong>DataInputStream（数据输入流）</strong><br>用于读取数据输出流写出去的数据</li>
</ul>
</li>
</ul>
</li>
<li><strong>Commons-io框架</strong><br><img src="https://pic1.imgdb.cn/item/68da72acc5157e1a8845cc7b.png"><br><img src="https://pic1.imgdb.cn/item/68da72d0c5157e1a8845cca9.png"><br><img src="https://pic1.imgdb.cn/item/68da73f2c5157e1a8845ce13.png"><br><img src="https://pic1.imgdb.cn/item/68dd0a45c5157e1a884cfba2.png"></li>
</ul>
<h2 id="day13"><a href="#day13" class="headerlink" title="day13"></a>day13</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><strong>线程</strong>（Thread）是一个程序内部的一条执行流程<br>程序中如果只有一条执行流程，那这个程序就是单线程的程序</p>
<h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p><strong>多线程</strong>是指从软硬件上实现的多条执行流程的技术（多条线程由CPU负责调度执行）</p>
<ul>
<li><p><strong>创建线程</strong><br><strong>创建线程的注意事项：</strong><br>  1、启动线程必须是调用start方法，不是调用run方法</p>
<ol>
<li>直接调用run方法会当成普通方法执行，此时相当于还是单线程执行</li>
<li>只有调用start方法才是启动一个新的线程执行</li>
</ol>
<p>  2、不要把主线程任务放在启动子线程之前</p>
<ul>
<li><strong>多线程的创建方式一：继承Thread类</strong><blockquote>
<p>main方法本身是由一条主线程负责推荐执行的</p>
</blockquote>
  <img src="https://pic1.imgdb.cn/item/68da7db5c5157e1a8845dada.png"><br>  <strong>方式一优缺点：</strong><br>  优点：编码简单<br>  缺点：线程类已经继承Thread，无法继承其他类，不利于功能的扩展</li>
<li><strong>多线程的创建方式二：实现Runnable接口</strong><br>  <img src="https://pic1.imgdb.cn/item/68da8189c5157e1a8845eca2.png"><br>  <strong>方式二优缺点：</strong><br>  优点：任务类只是实现接口，可以继续继承其他类、实现其他接口，扩展性强<br>  缺点：需要多一个Runnable对象<br>  <img src="https://pic1.imgdb.cn/item/68da822dc5157e1a8845ed6f.png"><br>  <img src="https://pic1.imgdb.cn/item/68da82c7c5157e1a8845eee0.png"></li>
<li><strong>多线程的创建方式三：实现Callable接口</strong><br>  <strong>前两种线程创建方式都存在的一个问题</strong>：假如线程执行完毕后有一些数据需要返回，他们重写的run方法均不能直接返回结果<br>  JDK5.0提供了Callable接口和FutureTask类来实现（多线程的第三种创建方式）<br>  <font color=red>这种方式最大的优点：可以返回线程执行完毕后的结果</font><br>  <img src="https://pic1.imgdb.cn/item/68da856ec5157e1a8845fb6d.png"><br>  FutureTask本质是一个Runnable线程任务对象，可以交给Thread线程对象处理<br>  获取数据时建议分开try-catch，可以互不影响<br>  <img src="https://pic1.imgdb.cn/item/68da88f8c5157e1a884618c8.png"><br>  拿结果时，如果主线程发现本线程还没有执行完毕，会让出CPU，等本线程执行完毕后，才会往下执行</li>
</ul>
</li>
<li><p><strong>线程的常用方法</strong><br><img src="https://pic1.imgdb.cn/item/68da90a2c5157e1a884635b8.png"></p>
</li>
</ul>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p><font color=red>多个线程，同时操作同一个共享资源</font>的时候，可能会出现业务安全问题</p>
<h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><p>线程同步是线程安全问题的解决方案<br><strong>核心思想</strong>：让多个线程先后依次访问共享资源，这样就可以避免出现线程安全问题<br><font color=red>线程同步的常见方案：</font>加锁，每次只允许一个线程加锁，加锁后才能进入访问，访问完毕后自动解锁，然后其他线程才能再加锁进来</p>
<ul>
<li><p><strong>方式一：同步代码块</strong><br><font color=red>作用：</font>把访问共享资源的核心代码给上锁，以此保证线程安全</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(同步锁)&#123;</span><br><span class="line">    访问共享资源的核心代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <font color=red>原理：</font>每次只允许一个线程加锁后进入，执行完毕后自动解锁，其他线程才可以进来执行</p>
</li>
<li><p><strong>同步锁的注意事项</strong><br>  对于当前同时执行的线程来说，同步锁必须是同一把（<font color=red>同一个对象</font>），否则会出bug</p>
</li>
<li><p><strong>锁对象的使用规范</strong><br>  <font color=red>建议使用共享资源作为锁对象</font>，对于实例方法建议使用<font color=red>this</font>作为锁对象<br>  对于静态方法建议使用<font color=red>字节码（类名.class）</font>对象作为锁对象<br>  <img src="https://pic1.imgdb.cn/item/68daa540c5157e1a8846a10d.png"></p>
</li>
<li><p><strong>方式二：同步方法</strong><br><font color=red>作用：</font>把访问共享资源的核心方法给上锁，以此保证线程安全</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 synchronized 返回值类型 方法名称（形参列表）&#123;</span><br><span class="line">    操作共享资源的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <strong>同步方法底层原理</strong></p>
<ul>
<li>同步方法其实底层也是有隐式锁对象的，只是锁的范围是整个方法代码</li>
<li>如果方法是实例方法：同步方法默认用<strong>this</strong>作为的锁对象</li>
<li>如果方法是静态方法：同步方法默认用<strong>类名.class</strong>作为的锁对象</li>
</ul>
</li>
<li><p><strong>同步代码块好还是同步方法好？</strong></p>
<ul>
<li>范围上：同步代码块锁的范围更小（效率更高），同步方法锁的范围更大</li>
<li>可读性：同步方法更好</li>
</ul>
</li>
<li><p><strong>方式三：Lock锁</strong><br><img src="https://pic1.imgdb.cn/item/68daab28c5157e1a8846b2c4.png"><br>最好将锁对象定义为final，保护锁对象<br>unlock最好放在finally里，这样即使出现异常也能正常释放锁</p>
</li>
</ul>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>线程池就是一个<font color=red>可以复用线程的技术</font></p>
<ul>
<li><strong>不使用线程池的问题</strong><br>用户每发起一个请求，后台就需要创建一个新线程来处理，下次新任务来了肯定又要创建新线程处理的，<font color=red>创建新线程的开销是很大的，并且请求过多时，肯定会产生大量的线程出来</font>，这样会严重影响系统的性能。</li>
<li><strong>线程池的工作原理</strong><br><img src="https://pic1.imgdb.cn/item/68dab020c5157e1a8846b77c.png"></li>
<li><strong>创建线程池</strong><br>JDK5.0起提供了代表线程池的接口：ExecutorService<br><strong>如何创建线程池对象</strong><br>方式一：使用ExecutorService的实现类ThreadPoolExecutor自创建一个线程池对象<br>方式二：使用Executors（线程池的工具类）调用方法返回不同特点的线程池对象<ul>
<li><strong>方式一：使用ThreadPoolExecutor创建线程池</strong><br><img src="https://pic1.imgdb.cn/item/68dccbe7c5157e1a884c12dc.png"><br><strong>ExecutorService的常用方法</strong><br><img src="https://pic1.imgdb.cn/item/68dcf99fc5157e1a884c92fc.png"><br><strong>线程池的注意事项</strong><br><img src="https://pic1.imgdb.cn/item/68dcfa70c5157e1a884c9939.png"><ul>
<li><strong>处理Runnable任务</strong><br>  <img src="https://pic1.imgdb.cn/item/68dcf9ddc5157e1a884c9516.png"><br>  任务队列有ArrayBlockingQueue和LinkedBlockingQueue</li>
<li><strong>处理Callable任务</strong><br>  <img src="https://pic1.imgdb.cn/item/68dcfc52c5157e1a884ca485.png"></li>
</ul>
</li>
<li><strong>方式二：通过Executors创建线程池</strong><br><img src="https://pic1.imgdb.cn/item/68dcfe3bc5157e1a884caa4a.png"><br><strong>Executors可能存在的陷阱</strong><br><img src="https://pic1.imgdb.cn/item/68dd0382c5157e1a884cc990.png"></li>
</ul>
</li>
<li><strong>并发&#x2F;并行</strong><br><strong>进程</strong><br>正在运行的程序（软件）就是一个独立的进程<br>线程是属于进程的，一个进程中可以同时运行很多个线程<br><font color=red>进程中的多个线程其实是并发和并行执行的</font><br><strong>并发的含义</strong><br>进程中的线程是由CPU负责调度执行的，但CPU能同时处理线程的数量优先，为了保证全部线程都能往前执行，CPU会轮询为系统的每个线程服务，由于CPU切换的速度很快，给我们的感觉这些线程在同时执行，这就是并发<br><strong>并行的含义</strong><br>在同一个时刻上，同时有多个线程在被CPU调度执行<br><strong>简单说说多线程是怎么执行的？</strong><br>并发和并行同时进行的</li>
</ul>
<h2 id="day14"><a href="#day14" class="headerlink" title="day14"></a>day14</h2><h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><p>可以让设备中的程序与网络上其他设备中的程序进行数据交互的技术（实现网络通信）</p>
<ul>
<li><strong>基本的通信架构</strong><br>基本的通信架构有2种形式：CS架构（Client客户端&#x2F;Server服务端）、BS架构（Browser浏览器&#x2F;Server服务端）<br><img src="https://pic1.imgdb.cn/item/68de0f7cc5157e1a884e7596.png"><br><img src="https://pic1.imgdb.cn/item/68de0fb2c5157e1a884e75c9.png"><br><font color=red>无论是CS架构，还是BS架构的软件都必须依赖网络编程</font><br>Java提供了哪些网络编程解决方案？<br><font color=red><code>java.net.*</code>包下提供了网络编程的解决方案</font></li>
</ul>
<h4 id="网络编程三要素"><a href="#网络编程三要素" class="headerlink" title="网络编程三要素"></a>网络编程三要素</h4><p><img src="https://pic1.imgdb.cn/item/68de10b0c5157e1a884e7603.png"></p>
<ul>
<li><strong>IP</strong><br><img src="https://pic1.imgdb.cn/item/68de1123c5157e1a884e7618.png"><br><img src="https://pic1.imgdb.cn/item/68de11ffc5157e1a884e7656.png"><br><strong>DNS域名解析</strong><br><img src="https://pic1.imgdb.cn/item/68de1293c5157e1a884e767f.png"><br>第一次访问时本机的DNS域名解析器还不知道域名对应的IP地址，会先找运营商（安装宽带的）的DNS域名解析器找对应的IP地址<br><strong>公网IP、内网IP</strong><br><img src="https://pic1.imgdb.cn/item/68de1452c5157e1a884e778d.png"><br><strong>InetAddress</strong><br>代表IP地址<br><img src="https://pic1.imgdb.cn/item/68de1613c5157e1a884e7894.png"><br><img src="https://pic1.imgdb.cn/item/68de15e7c5157e1a884e7864.png"></li>
<li><strong>端口</strong><br>用来标记正在计算机设备上运行的应用程序，被规定为一个16位的二进制，范围是0<del>65535<br><strong>端口分类</strong><br>周知端口：0</del>1023，被预先定义的知名应用占用（如：HTTP占用80，FTP占用21）<br>注册端口：1024~49151，分配给用户进程或某些应用程序<br>动态端口：49152到65535，之所以称为动态端口，是因为它一般不固定分配某种进程，而是动态分配<br><font color=red>注意：我们自己开发的程序一般选择使用注册端口，且一个设备中不能出现两个程序的端口号一样，否则报错</font></li>
<li><strong>协议</strong><br>网络上通信的设备，实现规定的连接规则，以及传输数据的规则被称为网络通信协议<br><strong>开放式网络互连标准：OSI网络参考模型</strong><br><img src="https://pic1.imgdb.cn/item/68de1900c5157e1a884e7ba3.png"><br><strong>传输层的2个通信协议</strong><ul>
<li>UDP（User Datagram Protocol）：用户数据报协议<br>  <img src="https://pic1.imgdb.cn/item/68de19a9c5157e1a884e7c4e.png"></li>
<li>TCP（Transmission Control Protocol）：传输控制协议<br>  <img src="https://pic1.imgdb.cn/item/68de1b75c5157e1a884e7dd2.png"><br>  <img src="https://pic1.imgdb.cn/item/68de1a48c5157e1a884e7cf7.png"><br>  传输数据会进行确认，以保证数据传输的可靠性<br>  <img src="https://pic1.imgdb.cn/item/68de1b57c5157e1a884e7dce.png"><br>  通信效率相对不高，可靠性更高，适用网页、文件下载、支付</li>
</ul>
</li>
<li><strong>UDP通信的实现</strong><br>Java提供了一个<code>java.net.DatagramSocket</code>类来实现UDP通信<br><img src="https://pic1.imgdb.cn/item/68de29b8c5157e1a884e9b87.png"><br><img src="https://pic1.imgdb.cn/item/68de29c7c5157e1a884e9beb.png"><br><strong>多发多收</strong>：客户端和服务端都用while死循环，用户输入exit后退出循环</li>
<li><strong>TCP通信的实现</strong><br>Java提供了一个<code>java.net.Socket</code>类来实现TCP通信<br><img src="https://pic1.imgdb.cn/item/68de2efcc5157e1a884eb4ae.png"><br><img src="https://pic1.imgdb.cn/item/68de30c3c5157e1a884eb86f.png"><br>服务端是通过<code>java.net</code>包下的<code>ServerSocket</code>类来实现的<br><img src="https://pic1.imgdb.cn/item/68de3259c5157e1a884ec201.png"><br>客户端和服务端的字节输入输出流必须要对应<br><strong>多发多收</strong>：<br><img src="https://pic1.imgdb.cn/item/68e0b8a3c5157e1a88563992.png"><br>支持多个客户端消息：<br>用多线程<br><strong>BS架构的原理</strong><br><img src="https://pic1.imgdb.cn/item/68e1fe99c5157e1a885770dc.png"><br><img src="https://pic1.imgdb.cn/item/68e202fec5157e1a885771aa.png"><br><img src="https://pic1.imgdb.cn/item/68e2032cc5157e1a885771c9.png"><br><img src="https://pic1.imgdb.cn/item/68e20356c5157e1a885771e4.png"><br>线程对象其实也可以当成任务对象用</li>
</ul>
<h2 id="day15"><a href="#day15" class="headerlink" title="day15"></a>day15</h2><h3 id="项目实战-即时通讯"><a href="#项目实战-即时通讯" class="headerlink" title="项目实战-即时通讯"></a>项目实战-即时通讯</h3><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><ul>
<li><strong>时间相关的获取方案</strong><br><img src="https://pic1.imgdb.cn/item/68e206afc5157e1a88578d5e.png"></li>
<li><strong>StringBuilder</strong><br><img src="https://pic1.imgdb.cn/item/68e208a2c5157e1a88579bdd.png"></li>
<li><strong>BigDecimal</strong><br><img src="https://pic1.imgdb.cn/item/68e20d08c5157e1a8857acb9.png"><br><img src="https://pic1.imgdb.cn/item/68e20e2ec5157e1a8857ae1f.png"><br>BigDecimal解决精度丢失问题<br><img src="https://pic1.imgdb.cn/item/68e20d35c5157e1a8857acc5.png"></li>
</ul>
<h2 id="day16"><a href="#day16" class="headerlink" title="day16"></a>day16</h2><h3 id="Java高级技术"><a href="#Java高级技术" class="headerlink" title="Java高级技术"></a>Java高级技术</h3><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><p>就是针对最小的功能单元：方法，编写测试代码对其进行正确性测试<br><img src="https://pic1.imgdb.cn/item/68e23b61c5157e1a8858b9e1.png"></p>
<ul>
<li><strong>Junit单元测试框架</strong><br>可以用来对方法进行测试，它是第三方公司开源出来的（很多开发工具已经集成了Junit框架，比如IDEA）<br><strong>优点</strong>：<br>可以灵活的编写测试代码，可以针对某个方法执行测试，也支持一键完成对全部方法的自动化测试，且各自独立<br>不需要程序员去分析测试的结果，会自动生成测试报告出来<br><img src="https://pic1.imgdb.cn/item/68e24082c5157e1a8858bbaa.png"><br>有时测试方法中还要做断言：断言结果是否与预期结果一致<code>Assert.assertEquals()</code><br><img src="https://pic1.imgdb.cn/item/68e240dac5157e1a8858bbbc.png"></li>
</ul>
<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>反射就是：加载类，并允许以编程的方式解剖类中的各种成分（成员变量、方法、构造器等）<br><img src="https://pic1.imgdb.cn/item/68e241f4c5157e1a8858c016.png"></p>
<ul>
<li><strong>反射第一步：获得Class对象</strong><br><img src="https://pic1.imgdb.cn/item/68e243f1c5157e1a8858c543.png"><br><img src="https://pic1.imgdb.cn/item/68e243c7c5157e1a8858c539.png"></li>
<li><strong>反射第二步：获取类中的成分并操作</strong><br><img src="https://pic1.imgdb.cn/item/68e24d6ec5157e1a8858cb4d.png"><br><img src="https://pic1.imgdb.cn/item/68e24ddec5157e1a8858cc8e.png"><br><img src="https://pic1.imgdb.cn/item/68e24dc6c5157e1a8858cc46.png"><br><strong>暴力访问私有构造器、方法、属性</strong><br><img src="https://pic1.imgdb.cn/item/68e24e87c5157e1a8858ce86.png"></li>
<li><strong>反射的作用</strong><ol>
<li>基本作用：可以得到一个类的全部成分然后操作</li>
<li>可以破坏封装性</li>
<li>可以绕过泛型的约束（泛型编译成class文件后变成Object）<br><font color=red>最重要的用途是：适合做Java的框架，基本上，主流的框架都会基于反射设计出一些通用的功能</font><br><img src="https://pic1.imgdb.cn/item/68e26212c5157e1a8858e735.png"></li>
</ol>
</li>
</ul>
<h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>注解就是Java代码里的特殊标记，比如：@Override，@Test等，作用是：让其他程序根据注解信息来决定怎么执行该程序</p>
<blockquote>
<p>注意：注解可以用在类上、构造器上、方法上、成员变量上、参数上等位置处</p>
</blockquote>
<ul>
<li><strong>自定义注解</strong>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public @interface 注解名称&#123;</span><br><span class="line">    public 属性类型 属性名() default 默认值；（public默认存在）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <font color=red>注意要加()</font><br>  <strong>特殊属性名：value</strong><br>  如果注解中只有一个value属性，使用注解时，value名称可以不写<br>  <img src="https://pic1.imgdb.cn/item/68e5fedcc5157e1a885c3a2a.png"></li>
<li><strong>元注解</strong><br>指的是注解注解的注解  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="line">public @interface Test&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://pic1.imgdb.cn/item/68e60160c5157e1a885c3b63.png"><br><img src="https://pic1.imgdb.cn/item/68e60177c5157e1a885c3b79.png"><br><img src="https://pic1.imgdb.cn/item/68e6019fc5157e1a885c3ce9.png"></li>
<li><strong>注解的解析</strong><br>就是判断类上、方法上、成员变量上是否存在注解，并把注解里的内容给解析出来<br><strong>如何解析注解</strong><br><img src="https://pic1.imgdb.cn/item/68e602d1c5157e1a885c49af.png"></li>
<li><strong>注解的应用场景</strong><br><img src="https://pic1.imgdb.cn/item/68e60901c5157e1a885c693d.png"></li>
</ul>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p><img src="https://pic1.imgdb.cn/item/68e60a0fc5157e1a885c6981.png"><br><img src="https://pic1.imgdb.cn/item/68e60b4bc5157e1a885c69b1.png"><br><img src="https://pic1.imgdb.cn/item/68e61444c5157e1a885c6de4.png"><br><img src="https://pic1.imgdb.cn/item/68e61933c5157e1a885c71bd.png"><br>代理实际上是典型的AOP（切面编程）思想</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/26/java/" data-id="cmh7rsi2z00016kuv21z451gk" data-title="Java" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-web开发" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/13/web%E5%BC%80%E5%8F%91/" class="article-date">
  <time class="dt-published" datetime="2025-10-13T13:56:04.000Z" itemprop="datePublished">2025-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/13/web%E5%BC%80%E5%8F%91/">web开发</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>Hyper Text Transfer Protocol，超文本传输协议，规定了浏览器和服务器之间数据传输的规则<br><strong>特点</strong></p>
<ol>
<li>基于TCP协议：面向</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/13/web%E5%BC%80%E5%8F%91/" data-id="cmh7rsi2x00006kuvf2eobiic" data-title="web开发" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据结构" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
  <time class="dt-published" datetime="2025-09-16T14:25:25.000Z" itemprop="datePublished">2025-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="数据结构"><a href="#数据结构" class="headerlink" title=" 数据结构"></a><center> 数据结构</h2><h3 id="7-3-1-二叉排序树（BST）"><a href="#7-3-1-二叉排序树（BST）" class="headerlink" title="7.3.1 二叉排序树（BST）"></a>7.3.1 二叉排序树（BST）</h3><ul>
<li><p><strong>二叉排序树的查找</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//在二叉排序树中查找值位key的结点</span><br><span class="line">BSTNode *BST_Search(BSTree T,int key)&#123;</span><br><span class="line">    while(T!=nullptr&amp;&amp;key!=T-&gt;key)&#123;//若树空或等于根结点值，则结束循环</span><br><span class="line">        if(key&lt;T-&gt;key) T=T-&gt;child;//小于，则在左子树上查找</span><br><span class="line">        else T=T-&gt;rchild;//大于，则在右子树上查找</span><br><span class="line">    &#125;</span><br><span class="line">    return T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最坏空间复杂度O(1)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//在二叉排序树中查找值为key的结点（递归实现）</span><br><span class="line">BSTNode *BSTSearch(BSTree T,int key)&#123;</span><br><span class="line">    if(T==nullptr)</span><br><span class="line">        return nullptr;//查找失败</span><br><span class="line">    if(key==T-&gt;key)</span><br><span class="line">        return T;//查找成功</span><br><span class="line">    else if(key&lt;T-&gt;key)</span><br><span class="line">        return BSTSearch(T-&gt;lchild,key);//在左子树中找</span><br><span class="line">    else</span><br><span class="line">        return BSTSearch(T-&gt;rchild,key);//在右子树中找</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最坏空间复杂度O(h)</p>
</li>
<li><p><strong>二叉排序树的插入</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//在二叉排序树插入关键字为k的新结点（递归实现）</span><br><span class="line">int BST_Insert(BStree &amp;T,int k)&#123;</span><br><span class="line">    if(T==nullptr)&#123;//原树为空，新插入的结点为根结点</span><br><span class="line">        T=(BSTree)malloc(sizeof(BSTNode));</span><br><span class="line">        T-&gt;key=k;</span><br><span class="line">        T-&gt;lchild=T-&gt;rchild=nullptr;</span><br><span class="line">        return 1;//返回1，插入成功</span><br><span class="line">    &#125;</span><br><span class="line">    else if(k==T-&gt;key)//树中存在相同关键字的结点，插入失败</span><br><span class="line">        return 0;</span><br><span class="line">    else if(k&lt;T-&gt;key)//插入到T的左子树</span><br><span class="line">        return BST_Insert(T-&gt;lchild,,k);</span><br><span class="line">    else//插入到T的右子树</span><br><span class="line">        return BST_Insert(T-&gt;rchild,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意函数参数是引用类型<br>最坏空间复杂度O(h)</p>
</li>
<li><p><strong>二叉排序树的构造</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//按照str[]中的关键字序列建立二叉排序树</span><br><span class="line">void Creat_BST(BSTree &amp;T,int str[],int n)&#123;</span><br><span class="line">    T=nullptr;//初始时T为空树</span><br><span class="line">    int i=0;</span><br><span class="line">    while(i&lt;n)&#123;依次将每个关键字插入到二叉排序树中</span><br><span class="line">        BST_Insert(T,str[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>二叉排序树的删除</strong><br>先搜索找到目标结点：</p>
</li>
</ul>
<ol>
<li>若被删除结点z是叶结点，则直接删除，不会破坏二叉排序树的性质</li>
<li>若结点z只有一棵左子树或右子树，则让z的子树成为z父结点的子树，替代z的位置</li>
<li>若结点z有左、右两棵子树，则令z的直接后继（或直接前驱）替代z，然后从二叉排序树中删去这个直接后继（或直接前驱），这样就转换成了第一或第二种情况<br>原理：<br><code>左子树结点值&lt;根结点值&lt;右子树结点值</code><br><code>进行中序遍历，可以得到一个递增的有序序列</code><br>z的<strong>后继</strong>：z的右子树中最左下结点（该结点一定没有左子树）<br>z的<strong>前驱</strong>：z的左子树中最右下结点（该结点一定没有右子树）</li>
</ol>
<h3 id="7-3-2-1-平衡二叉树（AVL）"><a href="#7-3-2-1-平衡二叉树（AVL）" class="headerlink" title="7.3.2_1 平衡二叉树（AVL）"></a>7.3.2_1 平衡二叉树（AVL）</h3><p><strong>结点的平衡因子</strong>&#x3D;左子树高-右子树高（只可能是-1、0或1）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//平衡二叉树结点</span><br><span class="line">typedef struct AVLNode&#123;</span><br><span class="line">    int key;//数据域</span><br><span class="line">    int balance;//平衡因子</span><br><span class="line">    struct AVLNode *lchild,*rchild;</span><br><span class="line">&#125;AVLNode,*AVLTree;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>平衡二叉树的插入</strong><br><img src="https://pic1.imgdb.cn/item/68bfd8cb58cb8da5c88fbf0a.png"><br>每次调整的对象都是“<strong>最小不平衡子树</strong>”<br><img src="https://pic1.imgdb.cn/item/68bfd91958cb8da5c88fc12d.png"><br>在插入操作中，只要将最小不平衡子树调整平衡，则其他祖先结点都会恢复平衡</li>
<li><strong>调整最小不平衡子树</strong><br><img src="https://pic1.imgdb.cn/item/68bfd96858cb8da5c88fc307.png"><ul>
<li><strong>LL</strong><br>  <img src="https://pic1.imgdb.cn/item/68bfdbdb58cb8da5c88fdfd9.png"></li>
<li><strong>RR</strong><br>  <img src="https://pic1.imgdb.cn/item/68bfdc7c58cb8da5c88fe996.png"></li>
<li><strong>代码思路</strong><br>  <img src="https://pic1.imgdb.cn/item/68bfdd2c58cb8da5c88ffa40.png"></li>
<li><strong>LR</strong><br>  <img src="https://pic1.imgdb.cn/item/68bfdda258cb8da5c890043c.png"><br>  <img src="https://pic1.imgdb.cn/item/68bfde1558cb8da5c8900dd5.png"></li>
<li><strong>RL</strong><br>  <img src="https://pic1.imgdb.cn/item/68bfde5f58cb8da5c8901628.png"><br>  <img src="https://pic1.imgdb.cn/item/68bfde8858cb8da5c8901adb.png"></li>
</ul>
</li>
</ul>
<p><img src="https://pic1.imgdb.cn/item/68bfded058cb8da5c89021d9.png"><br>恢复原因：插入操作导致“最小不平衡子树”高度+1，经过调整后高度恢复</p>
<ul>
<li><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a><strong>练习</strong><br><img src="https://pic1.imgdb.cn/item/68bfe00658cb8da5c89040e6.png"><br><img src="https://pic1.imgdb.cn/item/68bfe01358cb8da5c89041fe.png"></h2><p>  <img src="https://pic1.imgdb.cn/item/68bfe09058cb8da5c89047bc.png"><br>  <img src="https://pic1.imgdb.cn/item/68bfe09e58cb8da5c890483c.png"></p>
</li>
<li><p><strong>查找效率分析</strong><br><img src="https://pic1.imgdb.cn/item/68bfe1eb58cb8da5c8905380.png"><br>1为根结点，令左子树结点数为$n_{h-1}$，右子树结点数为$n_{h-2}$，可得公式</p>
</li>
</ul>
<hr>
<p><img src="https://pic1.imgdb.cn/item/68bfe2c858cb8da5c8905ab4.png"></p>
<h3 id="7-3-2-2-平衡二叉树的删除"><a href="#7-3-2-2-平衡二叉树的删除" class="headerlink" title="7.3.2_2_平衡二叉树的删除"></a>7.3.2_2_平衡二叉树的删除</h3><p><img src="https://pic1.imgdb.cn/item/68bfe76a58cb8da5c89093db.png"></p>
<ul>
<li><h2 id="例子"><a href="#例子" class="headerlink" title="例子    "></a><strong>例子</strong><br>  <img src="https://pic1.imgdb.cn/item/68bfe8b658cb8da5c890aa65.png"><br>  <img src="https://pic1.imgdb.cn/item/68bfe8cd58cb8da5c890ad56.png"></h2><h2 id=""><a href="#" class="headerlink" title="    "></a>  <img src="https://pic1.imgdb.cn/item/68bfe96058cb8da5c890b956.png"><br>  <img src="https://pic1.imgdb.cn/item/68bfe97758cb8da5c890bbcd.png"></h2>  <img src="https://pic1.imgdb.cn/item/68bfe9d758cb8da5c890c191.png"><br>  <img src="https://pic1.imgdb.cn/item/68bfe9e458cb8da5c890c23b.png"><br>  <img src="https://pic1.imgdb.cn/item/68bfe9ef58cb8da5c890c2ea.png"><br>  <img src="https://pic1.imgdb.cn/item/68bfea2558cb8da5c890c60a.png"></li>
</ul>
<h3 id="7-3-3-1-红黑树的定义和性质"><a href="#7-3-3-1-红黑树的定义和性质" class="headerlink" title="7.3.3_1_红黑树的定义和性质"></a>7.3.3_1_红黑树的定义和性质</h3><p><strong>平衡二叉树AVL</strong>：插入&#x2F;删除很容易破坏“平衡”特性，需要频繁调整树的形态。如：插入操作导致不平衡，则需要先<strong>计算平衡因子，找到最小不平衡子树（时间开销大）</strong>，再进行LL&#x2F;RR&#x2F;LR&#x2F;RL调整<br><strong>红黑树RBT</strong>：插入&#x2F;删除很多时候不会破坏“红黑”特性，无需频繁调整树的形态。即便需要调整，一般都可以<font color=red>在常数级时间内完成</font><br><code>平衡二叉树</code>：适用于以查为主、很少插入&#x2F;删除的场景<br><code>红黑树</code>：适用于频繁插入、删除的场景，实用性更强</p>
<ul>
<li><strong>红黑树的定义</strong><br>红黑树是二叉排序树-&gt;左&lt;根&lt;右<br>与普通BST相比要求：<ol>
<li>每个结点或是红色的，或是黑色的</li>
<li>根结点是黑色的</li>
<li>叶结点（外部结点、NULL结点、失败结点）均是黑色的</li>
<li>不存在两个相邻的红结点（即红结点的父结点和孩子结点均是黑色）</li>
<li>对每个结点，从该结点到任一叶结点的简单路径上，所含黑结点的数目相同<blockquote>
<p>左根右，根叶黑，不红红，黑路同</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct RBnode&#123;</span><br><span class="line">    int key;//关键字的值</span><br><span class="line">    RBnode* parent;//父结点指针</span><br><span class="line">    RBnode* lChild;//左孩子指针</span><br><span class="line">    RBnode* rChild;//右孩子指针</span><br><span class="line">    int color;//结点颜色，如：可用0/1表示黑/红，也可使用枚举型enum表示颜色</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><strong>补充概念：结点的黑高</strong><br><strong>结点的黑高bh</strong>——从某结点出发（不含该结点）到达任一空叶结点的路径上黑结点总数</li>
<li><strong>红黑树的性质</strong><br>性质1：从根结点到叶结点的最长路径不大于最短路径的2倍（由4、5得）<br>性质2：有n个内部结点的红黑树高度h&lt;&#x3D;2 $log_2(n+1)$<br>性质2可证明红黑树**查找操作时间复杂度&#x3D;O($log_2(n)$)</li>
<li><strong>红黑树的查找</strong><br>与BST、AVL相同，从根出发，左小右大，若查找到一个空叶结点，则查找失败</li>
</ul>
<h3 id="7-3-3-2-红黑树的插入"><a href="#7-3-3-2-红黑树的插入" class="headerlink" title="7.3.3_2_红黑树的插入"></a>7.3.3_2_红黑树的插入</h3><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://pic1.imgdb.cn/item/68bff6af58cb8da5c89142a7.png"><br><img src="https://pic1.imgdb.cn/item/68bffd1e58cb8da5c8915e95.png"><br><img src="https://pic1.imgdb.cn/item/68bffd3858cb8da5c8915ebc.png"><br><img src="https://pic1.imgdb.cn/item/68bffd4758cb8da5c8915ed9.png"><br><img src="https://pic1.imgdb.cn/item/68bffd5c58cb8da5c8915efb.png"><br><img src="https://pic1.imgdb.cn/item/68bffd6d58cb8da5c8915f12.png"><br><img src="https://pic1.imgdb.cn/item/68bffd7958cb8da5c8915f29.png"><br><img src="https://pic1.imgdb.cn/item/68bffd8658cb8da5c8915f3e.png"><br><img src="https://pic1.imgdb.cn/item/68bffd8e58cb8da5c8915f49.png"><br><img src="https://pic1.imgdb.cn/item/68bffd9658cb8da5c8915f59.png"><br><img src="https://pic1.imgdb.cn/item/68bffde758cb8da5c8915fdb.png"><br><img src="https://pic1.imgdb.cn/item/68bffe0758cb8da5c891600d.png"><br><img src="https://pic1.imgdb.cn/item/68bffe0f58cb8da5c891601d.png"><br><img src="https://pic1.imgdb.cn/item/68bffe1858cb8da5c891602f.png"><br><img src="https://pic1.imgdb.cn/item/68bffe3858cb8da5c8916066.png"><br><img src="https://pic1.imgdb.cn/item/68bffe4658cb8da5c891607e.png"><br><img src="https://pic1.imgdb.cn/item/68bffe5e58cb8da5c89160a0.png"><br><img src="https://pic1.imgdb.cn/item/68bffe6a58cb8da5c89160ac.png"><br><img src="https://pic1.imgdb.cn/item/68bffe7858cb8da5c89160c5.png"><br><img src="https://pic1.imgdb.cn/item/68bffe8158cb8da5c89160d6.png"><br><img src="https://pic1.imgdb.cn/item/68bffe8d58cb8da5c89160e7.png"></h2><h2 id="与“黑高”相关的推论思考：根结点黑高为h的红黑树，内部结点数（关键字）至少有多少个回答：内部结点数最少的情况——总共h层黑结点的满树形态结论：若根结点黑高为h，内部结点数（关键字）最少有2-h-1个"><a href="#与“黑高”相关的推论思考：根结点黑高为h的红黑树，内部结点数（关键字）至少有多少个回答：内部结点数最少的情况——总共h层黑结点的满树形态结论：若根结点黑高为h，内部结点数（关键字）最少有2-h-1个" class="headerlink" title="- 与“黑高”相关的推论思考：根结点黑高为h的红黑树，内部结点数（关键字）至少有多少个回答：内部结点数最少的情况——总共h层黑结点的满树形态结论：若根结点黑高为h，内部结点数（关键字）最少有2^h-1个"></a><img src="https://pic1.imgdb.cn/item/68bffea858cb8da5c8916109.png"><br>- <strong>与“黑高”相关的推论</strong><br>思考：根结点黑高为h的红黑树，内部结点数（关键字）<font color=red>至少</font>有多少个<br>回答：内部结点数<font color=red>最少</font>的情况——总共h层黑结点的满树形态<br>结论：<font color=red>若根结点黑高为h，内部结点数（关键字）最少有2^h-1个</font></h2><p>性质1证明：任何一条查找失败路径上黑结点数量都相同，而路径上不能连续出现两个红结点，即红结点只能穿插在各个黑结点中间<br>性质2证明：若红黑树总高度&#x3D;h，则根结点黑高&gt;&#x3D;h&#x2F;2，因此内部结点数n&gt;&#x3D;$2^{h&#x2F;2}-1$，由此推出h&lt;&#x3D;2 $log_2(n+1)$</p>
<h3 id="7-3-3-3-红黑树的删除（难）"><a href="#7-3-3-3-红黑树的删除（难）" class="headerlink" title="7.3.3_3_红黑树的删除（难）"></a>7.3.3_3_红黑树的删除（难）</h3><p><strong>重要考点：</strong></p>
<ol>
<li>红黑树删除操作的时间复杂度&#x3D;O($log_2(n)$)</li>
<li>在红黑树中删除结点的处理方式和“<strong>二叉排序树的删除</strong>”一样</li>
<li>按2删除结点后，可能破坏“红黑树特性”，此时需要“<strong>调整结点颜色、位置</strong>”，使其再次满足“红黑树特性”</li>
</ol>
<h3 id="7-4-1-1-B树"><a href="#7-4-1-1-B树" class="headerlink" title="7.4.1_1 B树"></a>7.4.1_1 B树</h3><ul>
<li><strong>五叉查找树</strong><br><img src="https://pic1.imgdb.cn/item/68c1646d58cb8da5c89898c7.png"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//5叉排序树的结点定义</span><br><span class="line">struct Node&#123;</span><br><span class="line">    ElemType keys[4];//最多4个关键字</span><br><span class="line">    struct Node * child[5]；//最多5个孩子</span><br><span class="line">    int num;//结点中有几个关键字</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><strong>如何保证查找效率</strong><br>若每个结点内关键字太少，导致树变高，要查更多层结点，效率低<br><strong>策略</strong>：m叉查找树中，规定<font color=red>除了根结点外</font>，任何结点<font color=red>至少有[m&#x2F;2]（向上取整）个分叉</font>，即至少含有<font color=red>[m&#x2F;2]-1（向上取整）个关键字</font><br>eg：对于5叉排序树，规定除了根结点外，任何结点都至少有3个分叉，2个关键字<br><img src="https://pic1.imgdb.cn/item/68c168e058cb8da5c8989d56.png"><br><strong>策略</strong>：m叉查找树中，规定<font color=red>对于任何一个结点，其所有子树的高度都要相同</font></li>
<li><strong>B树</strong><br><img src="https://pic1.imgdb.cn/item/68c1696958cb8da5c8989d98.png"><br><img src="https://pic1.imgdb.cn/item/68c16ac458cb8da5c8989f38.png"><br><img src="https://pic1.imgdb.cn/item/68c16b1a58cb8da5c8989fcb.png"></li>
<li><strong>B树的高度</strong><br>最小高度：<br><img src="https://pic1.imgdb.cn/item/68c16d8158cb8da5c898a1ad.png"><br>最大高度思路一：<br><img src="https://pic1.imgdb.cn/item/68c16e3d58cb8da5c898a211.png"><br>最大高度思路二：<br><img src="https://pic1.imgdb.cn/item/68c16f5258cb8da5c898a2af.png"></li>
</ul>
<h3 id="7-4-1-2-B树的插入删除"><a href="#7-4-1-2-B树的插入删除" class="headerlink" title="7.4.1_2_B树的插入删除"></a>7.4.1_2_B树的插入删除</h3><ul>
<li><p><strong>B树的插入</strong><br><img src="https://pic1.imgdb.cn/item/68c1715658cb8da5c898a3bc.png"><br><img src="https://pic1.imgdb.cn/item/68c1716958cb8da5c898a3c5.png"><br><font color=red>新元素一定是插入到最底层“终端结点”，用“查找”来确定插入位置</font><br>如果90插入到根结点，则各个失败结点不属于同一层<br><img src="https://pic1.imgdb.cn/item/68c171fc58cb8da5c898a483.png"><br><img src="https://pic1.imgdb.cn/item/68c1720a58cb8da5c898a48e.png"><br><img src="https://pic1.imgdb.cn/item/68c1726b58cb8da5c898a4bf.png"><br><img src="https://pic1.imgdb.cn/item/68c1729258cb8da5c898a4de.png"><br><img src="https://pic1.imgdb.cn/item/68c172d558cb8da5c898a503.png"><br><img src="https://pic1.imgdb.cn/item/68c172e358cb8da5c898a50a.png"><br><img src="https://pic1.imgdb.cn/item/68c1735158cb8da5c898a553.png"></p>
</li>
<li><p><strong>B树的删除</strong><br>若被删除关键字在<font color=red>终端结点</font>，则直接删除该关键字（要注意结点关键字个数是否低于下限[m&#x2F;2]-1）<br>若被删除关键字在<font color=red>非终端结点</font>，则用直接前驱或直接后继来替代被删除的关键字<br><font color=red>直接前驱</font>：当前关键字<font color=red>左侧指针所指子树中“最右下”的元素</font><br><font color=red>直接后继</font>：当前关键字<font color=red>右侧指针所指子树中“最左下”的元素</font></p>
<blockquote>
<p>对非终端结点关键字的删除，必然可以转化为对终端结点的删除操作<br>向右兄弟借：</p>
</blockquote>
</li>
</ul>
<h2 id="向左兄弟借：兄弟不够借-合并："><a href="#向左兄弟借：兄弟不够借-合并：" class="headerlink" title="向左兄弟借：兄弟不够借-&gt;合并："></a><img src="https://pic1.imgdb.cn/item/68c174f858cb8da5c898a790.png"><br><img src="https://pic1.imgdb.cn/item/68c1750458cb8da5c898a7a1.png"><br>向左兄弟借：<br><img src="https://pic1.imgdb.cn/item/68c1756558cb8da5c898a846.png"><br><img src="https://pic1.imgdb.cn/item/68c1757958cb8da5c898a875.png"><br>兄弟不够借-&gt;合并：<br><img src="https://pic1.imgdb.cn/item/68c175b858cb8da5c898a913.png"><br><img src="https://pic1.imgdb.cn/item/68c175e958cb8da5c898a989.png"><br><img src="https://pic1.imgdb.cn/item/68c1760b58cb8da5c898a9d3.png"><br><img src="https://pic1.imgdb.cn/item/68c1763b58cb8da5c898aa1f.png"></h2><p><img src="https://pic1.imgdb.cn/item/68c1767758cb8da5c898aab0.png"></p>
<h3 id="7-4-2-B-树"><a href="#7-4-2-B-树" class="headerlink" title="7.4.2_B+树"></a>7.4.2_B+树</h3><h2 id="B-树的查找1-多路查找2-顺序查找-B-树-vs-B树1-m阶B-树：结点中的n个关键字对应n棵子树m阶B树：结点中的n个关键字对应n-1棵子树2-m阶B树：根结点的关键字数-n-in-1-m-1-其他结点的关键字数-n-in-m-2-1-m-1-m阶B-树：根结点的关键字数-n-in-1-m-其他结点的关键字数-n-in-m-2-m-3-m阶B-树：在B-树中，叶结点包含全部关键字，非叶结点中出现过的关键字也会出现在叶结点中m阶B树：在B树中，各结点中包含的关键字是不重复的4-m阶B-树：在B-树中，叶结点包含信息，所有非叶结点仅起索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址m阶B树：B树的结点中都包含了关键字对应的记录的存储地址"><a href="#B-树的查找1-多路查找2-顺序查找-B-树-vs-B树1-m阶B-树：结点中的n个关键字对应n棵子树m阶B树：结点中的n个关键字对应n-1棵子树2-m阶B树：根结点的关键字数-n-in-1-m-1-其他结点的关键字数-n-in-m-2-1-m-1-m阶B-树：根结点的关键字数-n-in-1-m-其他结点的关键字数-n-in-m-2-m-3-m阶B-树：在B-树中，叶结点包含全部关键字，非叶结点中出现过的关键字也会出现在叶结点中m阶B树：在B树中，各结点中包含的关键字是不重复的4-m阶B-树：在B-树中，叶结点包含信息，所有非叶结点仅起索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址m阶B树：B树的结点中都包含了关键字对应的记录的存储地址" class="headerlink" title="- B+树的查找1. 多路查找2. 顺序查找- B+树 vs B树1. m阶B+树：结点中的n个关键字对应n棵子树m阶B树：结点中的n个关键字对应n+1棵子树2. m阶B树：根结点的关键字数$n\in[1,m-1]$其他结点的关键字数$n\in[[m&#x2F;2]-1,m-1]$m阶B+树：根结点的关键字数$n\in[1,m]$其他结点的关键字数$n\in[[m&#x2F;2],m]$3. m阶B+树：在B+树中，叶结点包含全部关键字，非叶结点中出现过的关键字也会出现在叶结点中m阶B树：在B树中，各结点中包含的关键字是不重复的4. m阶B+树：在B+树中，叶结点包含信息，所有非叶结点仅起索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址m阶B树：B树的结点中都包含了关键字对应的记录的存储地址"></a><img src="https://pic1.imgdb.cn/item/68c1788258cb8da5c898af5f.png"><br>- <strong>B+树的查找</strong><br>1. 多路查找<br><img src="https://pic1.imgdb.cn/item/68c17a3058cb8da5c898b217.png"><br>2. 顺序查找<br><img src="https://pic1.imgdb.cn/item/68c17c8758cb8da5c898b482.png"><br>- <strong>B+树 vs B树</strong><br>1. <strong>m阶B+树</strong>：结点中的n个关键字对应n棵子树<br><strong>m阶B树</strong>：结点中的n个关键字对应n+1棵子树<br>2. <strong>m阶B树</strong>：根结点的关键字数$n\in[1,m-1]$<br>其他结点的关键字数$n\in[[m&#x2F;2]-1,m-1]$<br><strong>m阶B+树</strong>：根结点的关键字数$n\in[1,m]$<br>其他结点的关键字数$n\in[[m&#x2F;2],m]$<br>3. <strong>m阶B+树</strong>：在B+树中，叶结点包含全部关键字，非叶结点中出现过的关键字也会出现在叶结点中<br><strong>m阶B树</strong>：在B树中，各结点中包含的关键字是不重复的<br>4. <strong>m阶B+树</strong>：在B+树中，叶结点包含信息，所有非叶结点仅起索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址<br><strong>m阶B树</strong>：B树的结点中都包含了关键字对应的记录的存储地址</h2><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="https://pic1.imgdb.cn/item/68c180ad58cb8da5c898b92c.png"><br><img src="https://pic1.imgdb.cn/item/68c1812858cb8da5c898b98c.png"></h2><p><img src="https://pic1.imgdb.cn/item/68c1813658cb8da5c898b995.png"></p>
<h3 id="7-5-1-散列表的基本概念"><a href="#7-5-1-散列表的基本概念" class="headerlink" title="7.5.1 散列表的基本概念"></a>7.5.1 散列表的基本概念</h3><ul>
<li><strong>散列表、散列函数</strong><br><strong>散列表（哈希表，Hash Table）</strong>：是一种数据结构。<font color=red>特点是：可以根据数据元素的关键字计算出它在散列表的存储地址</font><br><strong>散列函数（哈希函数）</strong>：Addr&#x3D;H(key)建立了<font color=red>“关键字”-&gt;“存储地址”</font>的映射关系<br><font color=red>理想情况下，在散列表中查找一个元素的时间复杂度为O(1)</font></li>
<li><strong>冲突、同义词</strong><br><strong>冲突（碰撞）</strong>：在散列表中插入一个数据元素时，需要根据关键字的值确定其存储地址，若该地址已经存储了其他元素，则称这种情况为“冲突（碰撞）”<br><strong>同义词</strong>：若不同的关键字通过散列函数映射到同一个存储地址，则称它们为“同义词”</li>
<li><strong>如何减少冲突</strong><br>构造更适合的散列函数，让各个关键字尽可能地映射到不同的存储位置，从而减少“冲突”<ul>
<li><strong>拉链法</strong><br>  <img src="https://pic1.imgdb.cn/item/68c905d0c5157e1a880a7e1e.png"></li>
<li><strong>开放定址法</strong><br>  <img src="https://pic1.imgdb.cn/item/68c905ebc5157e1a880a7ec1.png"></li>
</ul>
</li>
</ul>
<h3 id="7-2-5-散列函数的构造"><a href="#7-2-5-散列函数的构造" class="headerlink" title="7.2.5 散列函数的构造"></a>7.2.5 散列函数的构造</h3><ul>
<li><strong>设计散列函数时应该注意什么</strong><br><img src="https://pic1.imgdb.cn/item/68c906b8c5157e1a880a83e9.png"></li>
<li><strong>除留余数法</strong><br><strong>H(key)&#x3D;key%p</strong><br>散列表长为m，<font color=red>取一个不大于m但最接近或等于m的质数p</font><br><strong>适用场景</strong>：较为通用，只要关键字是整数即可</li>
</ul>
<hr>
<p><strong>拓展：为什么除留余数法要对质数取余</strong><br>原因：对质数取余，可以分布更均匀，从而减少冲突（取余运算会被“公因子”影响，参见《数论》）</p>
<hr>
<ul>
<li><strong>直接定址法</strong><br><strong>H(key)&#x3D;key或H(key)&#x3D;a*key+b</strong><br>其中，a和b是常数。这种方法计算最简单，且不会产生冲突。若关键字分布不连续，空位较多，则会造成存储空间的浪费<br><strong>适用场景</strong>：关键字分布基本连续</li>
<li><strong>数字分析法</strong><br><img src="https://pic1.imgdb.cn/item/68c906b8c5157e1a880a83e9.png"></li>
<li><strong>平方取中法</strong><br><img src="https://pic1.imgdb.cn/item/68c916c0c5157e1a880b0d4c.png"></li>
</ul>
<h3 id="7-5-3-1-处理冲突的方法-拉链法"><a href="#7-5-3-1-处理冲突的方法-拉链法" class="headerlink" title="7.5.3_1 处理冲突的方法_拉链法"></a>7.5.3_1 处理冲突的方法_拉链法</h3><h2 id="拉链法（又称链接法、链地址法）：把所有“同义词”存储在一个链表中-散列表的插入操作（拉链法解决冲突）考试时默认用头插法-散列表的查找操作（拉链法解决冲突）在分析查找长度时，通常只统计“关键字的对比次数”，而链表“空指针的对比次数”不计入查找长度-散列表的删除操作（拉链法解决冲突）Step1：根据散列函数计算目标元素的散列地址Step2：顺序查找散列地址对应的链表，若查找成功，将目标元素从链表中删除"><a href="#拉链法（又称链接法、链地址法）：把所有“同义词”存储在一个链表中-散列表的插入操作（拉链法解决冲突）考试时默认用头插法-散列表的查找操作（拉链法解决冲突）在分析查找长度时，通常只统计“关键字的对比次数”，而链表“空指针的对比次数”不计入查找长度-散列表的删除操作（拉链法解决冲突）Step1：根据散列函数计算目标元素的散列地址Step2：顺序查找散列地址对应的链表，若查找成功，将目标元素从链表中删除" class="headerlink" title="拉链法（又称链接法、链地址法）：把所有“同义词”存储在一个链表中- 散列表的插入操作（拉链法解决冲突）考试时默认用头插法- 散列表的查找操作（拉链法解决冲突）在分析查找长度时，通常只统计“关键字的对比次数”，而链表“空指针的对比次数”不计入查找长度- 散列表的删除操作（拉链法解决冲突）Step1：根据散列函数计算目标元素的散列地址Step2：顺序查找散列地址对应的链表，若查找成功，将目标元素从链表中删除"></a><font color=red>拉链法</font>（又称链接法、链地址法）：把所有“同义词”存储在一个链表中<br>- <strong>散列表的插入操作（拉链法解决冲突）</strong><br><img src="https://pic1.imgdb.cn/item/68c9189ec5157e1a880b1571.png"><br>考试时默认用头插法<br>- <strong>散列表的查找操作（拉链法解决冲突）</strong><br><img src="https://youke1.picui.cn/s1/2025/09/16/68c918f95ac5d.png" alt="1758009622146.png"><br>在分析查找长度时，通常只统计“关键字的对比次数”，而链表“空指针的对比次数”不计入查找长度<br>- <strong>散列表的删除操作（拉链法解决冲突）</strong><br>Step1：根据散列函数计算目标元素的散列地址<br>Step2：顺序查找散列地址对应的链表，若查找成功，将目标元素从链表中删除</h2><p><strong>拓展：插入操作的小优化</strong><br>新元素插入链表时，若能保持链表有序，可以略微提高“查找”效率</p>
<h3 id="7-5-3-2-处理冲突的方法-开放定址法"><a href="#7-5-3-2-处理冲突的方法-开放定址法" class="headerlink" title="7.5.3_2 处理冲突的方法_开放定址法"></a>7.5.3_2 处理冲突的方法_开放定址法</h3><p><font color=red>开放定址法</font>：如果发生“冲突”，就给新元素找另一个空闲位置<br>为什么叫“开放定址”——一个散列地址，既对同义词开放，也对非同义词开放</p>
<ul>
<li><strong>开放定址法的基本原理</strong><br><img src="https://youke1.picui.cn/s1/2025/09/16/68c91c24a3a1d.png" alt="1758010431032.png"></li>
<li><strong>线性探测法（插入、查找操作）</strong><br><img src="https://youke1.picui.cn/s1/2025/09/16/68c91dccbbefd.png" alt="1758010856611.png"></li>
<li><strong>平方探测法（插入、查找操作）</strong><br><img src="https://youke1.picui.cn/s1/2025/09/16/68c91e3f1abf6.png" alt="1758010968189.png"></li>
<li><strong>双散列法（插入、查找操作）</strong><br><img src="https://youke1.picui.cn/s1/2025/09/16/68c91ef622b65.png" alt="1758011154186.png"></li>
<li><strong>伪随机序列法（插入、查找操作）</strong><br><img src="https://youke1.picui.cn/s1/2025/09/16/68c91f34eebd4.png" alt="1758011217165.png"></li>
<li><strong>如何删除一个元素</strong><br><img src="https://youke1.picui.cn/s1/2025/09/16/68c92031768c2.png" alt="1758011470315.png"></li>
<li><strong>关于删除操作</strong><br><img src="https://youke1.picui.cn/s1/2025/09/16/68c91ff9a22a0.png" alt="1758011413746.png"><br><font color=red>带来的问题：查找效率低下，散列表看起来很满，实则很空</font><br>Tips：可以不定期整理散列表内的数据<blockquote>
<p>注：新元素也可以插入到已被“逻辑删除”的地址</p>
</blockquote>
</li>
</ul>
<hr>
<p><strong>拓展：“探测覆盖率”</strong></p>
<ul>
<li><strong>线性探测法</strong><br><img src="https://pic1.imgdb.cn/item/68c9222ac5157e1a880b6ad5.png"></li>
<li><strong>平方探测法</strong><br><img src="https://pic1.imgdb.cn/item/68c92285c5157e1a880b7200.png"></li>
<li><strong>双散列法</strong></li>
<li><img src="https://pic1.imgdb.cn/item/68c92383c5157e1a880b8195.png"><br>若表长本身就是质数，一定跟任何一个小于它的数（1除外）互质</li>
<li><strong>伪随机序列法的“探测覆盖率”</strong><br><img src="https://pic1.imgdb.cn/item/68c92450c5157e1a880b8b52.png"></li>
</ul>
<h3 id="7-5-4-散列查找的性能分析（以线性探测法为例）"><a href="#7-5-4-散列查找的性能分析（以线性探测法为例）" class="headerlink" title="7.5.4 散列查找的性能分析（以线性探测法为例）"></a>7.5.4 散列查找的性能分析（以线性探测法为例）</h3><p><img src="https://pic1.imgdb.cn/item/68c925e9c5157e1a880b9759.png"><br><img src="https://pic1.imgdb.cn/item/68c92657c5157e1a880b9a15.png"><br><strong>易错点</strong>：<br><img src="https://pic1.imgdb.cn/item/68c92741c5157e1a880ba35d.png"><br><font color=red>采用开放定址法时，删除一个元素是逻辑删除，而非物理删除！这一点将影响查找长度的计算</font></p>
<ul>
<li><strong>装填因子</strong><br><img src="https://pic1.imgdb.cn/item/68c92833c5157e1a880baef7.png"></li>
<li><strong>聚集（堆积）现象</strong><br>在处理冲突的过程中，几个初始散列地址不同的元素争夺同一个后继散列地址的现象称作“聚集”（或称作“堆积”）<br><strong>线性探测法</strong>在发生冲突时，总是往后探测相邻的后一个单元，<strong>很容易造成</strong>同义词、非同义词的“<strong>聚集（堆积）</strong>”现象，<strong>从而影响查找效率，导致ASL提升</strong></li>
<li><strong>使用“平方探测法”减少聚集现象</strong><br><img src="https://pic1.imgdb.cn/item/68c92ac1c5157e1a880bc7fd.png"></li>
</ul>
<h3 id="8-1-排序的基本概念"><a href="#8-1-排序的基本概念" class="headerlink" title="8.1_排序的基本概念"></a>8.1_排序的基本概念</h3><ul>
<li><strong>排序算法的评价指标</strong><br>时间复杂度+空间复杂度、稳定性<br><img src="https://pic1.imgdb.cn/item/68c93a1ec5157e1a880ca523.png"><br>稳定的排序算法一定比不稳定的好？<br>不一定，看实际需求</li>
<li><strong>排序算法的分类</strong><ul>
<li><strong>内部排序</strong><br>  数据都在内存中（关注如何使算法时、空复杂度更低）</li>
<li><strong>外部排序</strong><br>  数据太多，无法全部放入内存（还要关注如何使读&#x2F;写磁盘次数更少）</li>
</ul>
</li>
</ul>
<h3 id="8-2-1-8-2-2-插入排序"><a href="#8-2-1-8-2-2-插入排序" class="headerlink" title="8.2.1+8.2.2_插入排序"></a>8.2.1+8.2.2_插入排序</h3><ul>
<li><strong>算法实现</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//直接插入排序</span><br><span class="line">void InsertSort(int A[],int n)&#123;</span><br><span class="line">    int i,j,temp;</span><br><span class="line">    for(i=1;i&lt;n;i++)//将各元素插入已排好序的序列中</span><br><span class="line">        if(A[i]&lt;A[i-1])&#123;//若A[i]关键字小于前驱</span><br><span class="line">            temp=A[i];//temp暂存A[i]</span><br><span class="line">            for(j=i-1;j&gt;=0&amp;&amp;A[j]&gt;temp;--j)//检查所有前面已排好序的元素</span><br><span class="line">                A[j+1]=A[j];//所有大于temp的元素都向后挪位</span><br><span class="line">            A[j+1]=temp;//复制到插入位置</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>带哨兵</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//直接插入排序（带哨兵）</span><br><span class="line">void InsertSort(int A[],int n)&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    for(i=2;i&lt;=n;i++)//依次将A[2]~A[n]插入到前面已排序序列</span><br><span class="line">        if(A[i]&lt;A[i-1])&#123;//若A[i]关键码小于其前驱，将A[i]插入有序表</span><br><span class="line">            A[0]=A[i];//复制为哨兵，A[0]不存放元素</span><br><span class="line">            for(j=i-1;A[0]&lt;A[j];--j)//从后往前查找待插入位置</span><br><span class="line">                A[j+1]=A[j];//向后挪位</span><br><span class="line">            A[j+1]=A[0];//复制到插入位置</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>空间复杂度</strong>：O(1)<br><strong>时间复杂度</strong>：主要来自对比关键字、移动元素<br>若有n个元素，则需要n-1趟处理<br><strong>最好情况</strong>：原本就有序,O(n)<br><img src="https://pic1.imgdb.cn/item/68c9444bc5157e1a880cfeb7.png"><br><strong>最坏情况</strong>：原本为逆序,O(n²)<br><img src="https://pic1.imgdb.cn/item/68c94466c5157e1a880d0059.png"><br><strong>平均</strong>时间复杂度：O(n²)<br><strong>算法稳定性</strong>：稳定</li>
<li><strong>优化——折半插入排序</strong><br><img src="https://pic1.imgdb.cn/item/68c947b5c5157e1a880d2827.png"><br><img src="https://pic1.imgdb.cn/item/68c9476fc5157e1a880d280f.png"><br>当low&gt;high时折半查找停止，应将[low,i-1]内的元素全部右移，并将A[0]复制到low所指位置<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//折半插入排序</span><br><span class="line">void InsertSort(int A[],int n)&#123;</span><br><span class="line">    int i,j,low,high,mid;</span><br><span class="line">    for(i=2;i&lt;=n;i++)&#123;//依次将A[2]~A[n]插入前面的已排序序列</span><br><span class="line">        A[0]=A[i];//将A[i]暂存到A[0]</span><br><span class="line">        low=1;high=i-1;//设置折半查找的范围</span><br><span class="line">        while(low&lt;=high)&#123;</span><br><span class="line">            mid=(low+high)/2;//取中间点</span><br><span class="line">            if(A[mid]&gt;A[0]) high=mid-1;//查找左半子表</span><br><span class="line">            else low=mid+1;//查找右半子表</span><br><span class="line">        &#125;</span><br><span class="line">        for(j=i-1;j&gt;=high+1;--j)</span><br><span class="line">            A[j+1]=A[j];//统一右移元素，空出插入位置</span><br><span class="line">        A[high+1]=A[0]//插入操作</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
时间复杂度依然是O(n²)</li>
<li><strong>对链表进行插入排序</strong><br><img src="https://pic1.imgdb.cn/item/68c94aacc5157e1a880d33e1.png"></li>
</ul>
<h3 id="8-2-3-希尔排序"><a href="#8-2-3-希尔排序" class="headerlink" title="8.2.3_希尔排序"></a>8.2.3_希尔排序</h3><p>希尔排序：先追求表中元素部分有序，再逐渐逼近全局有序<br><img src="https://pic1.imgdb.cn/item/68c94ca1c5157e1a880d42c4.png"><br>希尔本人建议：每次将增量缩小一半</p>
<ul>
<li><strong>算法实现</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//希尔排序</span><br><span class="line">void ShellSort(int A[],int n)&#123;</span><br><span class="line">    int d,i,j;</span><br><span class="line">    //A[0]只是暂存单元，不是哨兵，当j&lt;=0时，插入位置已到</span><br><span class="line">    for(d=n/2;d&gt;=1;d=d/2)//步长变化</span><br><span class="line">        for(i=d+1;i&lt;=n;++i)</span><br><span class="line">            if(A[i]&lt;A[i-d])&#123;需将A[i]插入有序增量子表</span><br><span class="line">                A[0]=A[i];//暂存在A[0]</span><br><span class="line">                for(j=i-d;j&gt;0&amp;&amp;A[0]&lt;A[j];j-=d)</span><br><span class="line">                    A[j+d]=A[j];//记录后移，查找插入的位置</span><br><span class="line">                A[j+d]=A[0];//插入</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
此写法的++i说明不是一个子序列排完再排另一个子序列，而是逐步排完</li>
<li><strong>算法性能分析</strong><br><strong>空间复杂度</strong>：O(1)<br><strong>时间复杂度</strong>：和增量序列$d_1$,$d_2$,$d_3$…的选择有关，目前<font color=red>无法用数学手段证明确切的时间复杂度</font><br>最坏时间复杂度为O(n²)，当n在某个范围内时，可达O(n¹·³)<br><img src="https://pic1.imgdb.cn/item/68c956ffc5157e1a880da787.png"></li>
</ul>
<h3 id="8-3-1-冒泡排序"><a href="#8-3-1-冒泡排序" class="headerlink" title="8.3.1_冒泡排序"></a>8.3.1_冒泡排序</h3><ul>
<li><strong>算法实现</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//冒泡排序</span><br><span class="line">void BubbleSort(int A[],int n)&#123;</span><br><span class="line">    for(int i=0;i&lt;n-1;i++)&#123;</span><br><span class="line">        bool flag=false;//表示本趟冒泡是否发生交换的标志</span><br><span class="line">        for(int j=n-1;j&gt;i;j--)//一趟冒泡过程</span><br><span class="line">            if(A[j-1]&gt;A[j])&#123;//若为逆序</span><br><span class="line">                swap(A[j-1],A[j]);//交换</span><br><span class="line">                flag=true</span><br><span class="line">            &#125;</span><br><span class="line">        if(flag==false)</span><br><span class="line">            return;//本趟遍历后没有发生交换，说明表已经有序</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>A[j-1]&gt;A[j]没有等号</strong>——只有A[j-1]&gt;A[j]时才交换，因此算法是稳定的<br><strong>j&gt;i</strong>——i所指位置之前的元素都已有序<br><strong>bool flag</strong>——如果某一趟排序过程中未发生“交换”，则算法可提前结束</li>
<li><strong>算法性能分析</strong><br><strong>空间复杂度</strong>：O(1)<br><strong>时间复杂度</strong><br>最好情况（有序）：O(n)<br>最坏情况（逆序）：<img src="https://pic1.imgdb.cn/item/68c959a5c5157e1a880dc082.png"><br>每次交换都需要移动元素3次<br>平均时间复杂度&#x3D;O(n²)<blockquote>
<p>注：冒泡排序同样适用于链表</p>
</blockquote>
</li>
</ul>
<h3 id="8-3-2-快速排序"><a href="#8-3-2-快速排序" class="headerlink" title="8.3.2_快速排序"></a>8.3.2_快速排序</h3><p><img src="https://pic1.imgdb.cn/item/68c95bf6c5157e1a880dd936.png"><br><img src="https://pic1.imgdb.cn/item/68c95ebfc5157e1a880dedb2.png"><br><strong>过程</strong>：<br>开始时low和high指针分别指向最左和最右，选取第一个元素为基准（枢轴），提出来，此时low指针指向空，看high指针，若high指针所指元素比基准小，该元素移到low所指位置，low指针右移（否则high指针一直左移）…最终，当low&#x3D;&#x3D;high时一次划分结束<br><strong>左边放小于，右边放大于等于</strong></p>
<ul>
<li><strong>算法实现</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//快速排序</span><br><span class="line">void QuickSort(int A[],int low,int high)&#123;</span><br><span class="line">    if(low&lt;high)&#123;//递归跳出的条件</span><br><span class="line">        int pivotpos=Partition(A,low,high);//划分</span><br><span class="line">        QuickSort(A,low,pivotpos-1);//划分左子表</span><br><span class="line">        QuickSort(A,pivotpos+1,high);//划分右子表</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//用第一个元素将待排序序列划分成左右两个部分</span><br><span class="line">int Partition(int A[],int low,int high)&#123;</span><br><span class="line">    int pivot=A[low];//第一个元素作为枢轴</span><br><span class="line">    while(low&lt;high)&#123;//用low、high搜索枢轴的最终位置</span><br><span class="line">        while(low&lt;high&amp;&amp;A[high]&gt;=pivot) --high;</span><br><span class="line">        A[low]=A[high];//比枢轴小的元素移动到左端</span><br><span class="line">         while(low&lt;high&amp;&amp;A[low]&lt;=pivot) ++low;</span><br><span class="line">        A[high]=A[low];//比枢轴大的元素移动到右端</span><br><span class="line">    &#125;</span><br><span class="line">    A[low]=pivot;//枢轴元素存放到最终位置</span><br><span class="line">    return low;//返回存放枢轴的最终位置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>算法效率分析</strong><br><strong>时间复杂度</strong>&#x3D;O(n*递归层数)<br><strong>空间复杂度</strong>&#x3D;O(递归层数)<br><img src="https://pic1.imgdb.cn/item/68c9670ec5157e1a880e05cb.png"><br><font color=red>最好</font>时间复杂度&#x3D;O(nlog₂(n))<br><font color=red>最坏</font>时间复杂度&#x3D;O(n²)<br><strong>平均时间复杂度</strong>&#x3D;O(nlog₂(n))<br><font color=red>最好</font>空间复杂度&#x3D;O(log₂(n))<br><font color=red>最坏</font>空间复杂度&#x3D;O(n)</li>
<li><strong>比较好的情况</strong><br><img src="https://pic1.imgdb.cn/item/68c9682ac5157e1a880e0df0.png"></li>
<li><strong>比较坏的情况</strong><br><img src="https://pic1.imgdb.cn/item/68c9683dc5157e1a880e0e36.png"><blockquote>
<p>快速排序是所有内部排序算法中平均性能最优的排序算法</p>
</blockquote>
</li>
<li><strong>稳定性</strong><br>不稳定</li>
</ul>
<h3 id="8-4-1-简单选择排序"><a href="#8-4-1-简单选择排序" class="headerlink" title="8.4.1_简单选择排序"></a>8.4.1_简单选择排序</h3><p>选择排序——简单选择排序、堆排序<br>选择排序：每一趟在待排元素中选取关键字最小（或最大）的元素加入有序子序列</p>
<ul>
<li><strong>算法实现</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//简单选择排序</span><br><span class="line">void SelectSort(int A[],int n)&#123;</span><br><span class="line">    for(int i=0;i&lt;n-1;i++)&#123;</span><br><span class="line">        int min=i;</span><br><span class="line">        for(int j=i+1;i&lt;n;j++)</span><br><span class="line">            if(A[j]&lt;A[min]) min=j;</span><br><span class="line">        if(min!=i) swap(A[i],A[min]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>算法性能分析</strong><br><strong>空间复杂度</strong>&#x3D;O(1)<br><strong>时间复杂度</strong>&#x3D;O(n²)<br>无论有序、逆序、还是乱序，一定需要n-1趟处理<br>总共需要对比关键字(n-1)+(n-2)+…+1&#x3D;n(n-1)&#x2F;2次<br>元素交换次数&lt;n-1</li>
<li><strong>稳定性</strong><br>不稳定</li>
<li><strong>适用性</strong><br>既可以用于顺序表，也可用于链表</li>
</ul>
<h3 id="8-4-2-1-堆排序"><a href="#8-4-2-1-堆排序" class="headerlink" title="8.4.2_1 堆排序"></a>8.4.2_1 堆排序</h3><ul>
<li><strong>什么是“堆（Heap）”</strong><br><img src="https://pic1.imgdb.cn/item/68ca1006c5157e1a880f3b43.png"></li>
<li><strong>如何基于“堆”进行排序</strong><br>堆顶元素关键字最大<br>若能把数组整理成堆形式，可简化选择排序</li>
<li><strong>建立大根堆</strong><br><strong>思路</strong>：把所有非终端结点都检查一遍，是否满足大根堆的要求，如果不满足，则进行调整<br>在顺序存储的完全二叉树中，<font color=red>非终端结点编号i&lt;&#x3D;[n&#x2F;2]</font><br><img src="https://pic1.imgdb.cn/item/68ca1114c5157e1a880f499f.png"><br>从后往前检查非终端结点是否满足大根堆的要求，<font color=red>若不满足，将当前结点与更大的一个孩子互换</font><br><img src="https://pic1.imgdb.cn/item/68ca11bbc5157e1a880f5156.png"><br><code>若元素互换破坏的下一级的堆，则采用相同的方法继续往下调整（小元素不断“下坠”）</code><br><strong>代码实现</strong>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//建立大根堆</span><br><span class="line">void BuildMaxHeap(int A[],int len)&#123;</span><br><span class="line">    for(int i=len/2;i&gt;0;i--)//从后往前调整所有非终端结点</span><br><span class="line">        HeadAdjust(A,i,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//将以k为根的子树调整为大根堆</span><br><span class="line">void HeadAdjust(int A[],int k,int len)&#123;</span><br><span class="line">    A[0]=A[k];//A[0]暂存子树的根结点</span><br><span class="line">    for(int i=2*k;i&lt;=len;i*=2)&#123;//沿key较大的子结点向下筛选</span><br><span class="line">        if(i&lt;len&amp;&amp;A[i]&lt;A[i+1])</span><br><span class="line">            i++;//取key较大的子结点的下标</span><br><span class="line">        if(A[0]&gt;=A[i]) break;//筛选结束</span><br><span class="line">        else&#123;</span><br><span class="line">            A[k]=A[i];//将A[i]调整到双亲结点上</span><br><span class="line">            k=i;//修改k值，以便继续向下筛选</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k]=A[0];//被筛选结点的值放入最终位置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>基于大根堆进行排序</strong><br><img src="https://pic1.imgdb.cn/item/68ca168bc5157e1a880f984b.png"><br><img src="https://pic1.imgdb.cn/item/68ca171dc5157e1a880f9e18.png"><br><strong>代码实现</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//建立大根堆</span><br><span class="line">void BuildMaxHeap(int A[],int len)</span><br><span class="line"></span><br><span class="line">//将以k为根的子树调整为大根堆</span><br><span class="line">void HeadAdjust(int A[],int k,int len)</span><br><span class="line"></span><br><span class="line">//堆排序的完整逻辑</span><br><span class="line">void HeapSort(int A[],int len)&#123;</span><br><span class="line">    BuildMaxHeap(A,len);//初始建堆</span><br><span class="line">    for(int i=len;i&gt;1;i--)&#123;//n-1趟的交换和建堆过程</span><br><span class="line">        swap(A[i],A[1]);//堆顶元素和堆底元素交换</span><br><span class="line">        HeadAdjust(A,1,i-1);//把剩余的待排序元素整理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>算法效率分析</strong><br><img src="https://pic1.imgdb.cn/item/68ca1ba6c5157e1a880fbd7b.png"><br><img src="https://pic1.imgdb.cn/item/68ca1cadc5157e1a880fc2dc.png"><br><img src="https://pic1.imgdb.cn/item/68ca1cbbc5157e1a880fc2ff.png"><br><strong>建堆的过程，关键字对比次数不超过4n，建堆复杂度&#x3D;O(n)</strong></li>
<li><strong>稳定性</strong><br>堆排序是<font color=red>不稳定</font>的</li>
</ul>
<h3 id="8-4-2-2-堆的插入删除"><a href="#8-4-2-2-堆的插入删除" class="headerlink" title="8.4.2_2_堆的插入删除"></a>8.4.2_2_堆的插入删除</h3><ul>
<li><strong>在堆中插入新元素</strong><br>对于<strong>小</strong>根堆，新元素放到表尾，与父结点对比，若<strong>新元素</strong>比父结点<strong>更小</strong>，则将二者互换。新元素就这样一路“<strong>上升</strong>”，直到无法继续上升为止</li>
<li><strong>在堆中删除元素</strong><br>被删除的元素<strong>用堆底元素替代</strong>，然后让该元素不断“<strong>下坠</strong>”，直到无法下坠为止<blockquote>
<p>注意关键字的对比次数</p>
</blockquote>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" data-id="cmh7rsi3100036kuv9ayjbl0w" data-title="数据结构" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-计算机组成原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2025-09-05T14:33:18.000Z" itemprop="datePublished">2025-09-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title=" 计算机组成原理"></a><center> 计算机组成原理</h1><h2 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h2><ul>
<li><strong>计算机&#x2F;手机组成</strong><br><a target="_blank" rel="noopener" href="https://imgse.com/i/pVnk98f"><img src="https://s21.ax1x.com/2025/06/28/pVnk98f.png" alt="pVnk98f.png"></a></li>
<li><strong>计算机硬件能识别的数据——二进制0&#x2F;1</strong><br>用低&#x2F;高电平分别表示0&#x2F;1<br>硬件间通过主板上的印刷电路，可以传递多个二进制数位，每个二进制数位称为1bit</li>
</ul>
<h2 id="一、计算机系统概述"><a href="#一、计算机系统概述" class="headerlink" title="一、计算机系统概述"></a>一、计算机系统概述</h2><p>计算机系统&#x3D;硬件+软件</p>
<h3 id="1-1-计算机的发展"><a href="#1-1-计算机的发展" class="headerlink" title="1.1 计算机的发展"></a>1.1 计算机的发展</h3><ul>
<li><p><strong>软件</strong>：</p>
<ul>
<li><strong>系统软件</strong>——用来管理整个计算机系统（Eg.操作系统、数据库管理系统（DBMS）、标准程序库、网络软件（网卡驱动等）、语言处理程序、服务程序（Debug等））</li>
<li><strong>应用软件</strong>——按任务需要编织成的各种程序</li>
</ul>
</li>
<li><p><strong>硬件</strong></p>
</li>
</ul>
<ol>
<li><strong>第一代：电子管时代</strong><br>第一台电子数字计算机：ENIAC（1946），冯诺依曼<br>逻辑元件：<strong>电子管</strong><br>使用机器语言编程</li>
<li><strong>第二代：晶体管时代</strong><br>逻辑元件：<strong>晶体管</strong><br>体积、功耗降低<br>出现面向过程的程序设计语言<br>有了操作系统雏形</li>
<li><strong>第三代：中小规模集成电路时代</strong><br>高级语言迅速发展，有了分时操作系统</li>
<li><strong>第四代：大规模、超大规模集成电路时代</strong><br>开始出现微处理器（CPU）、微型计算机、个人计算机（PC）萌芽<br>操作系统：Windows、MacOS、Linux</li>
</ol>
<hr>
<ul>
<li><strong>微处理器的发展</strong><br>微型计算机的发展以微处理器技术为标志<br><strong>机器字长</strong>：计算机<strong>一次</strong>整数运算所能处理的二进制位数（目前都是64位）</li>
<li><strong>硬件的发展</strong><br>“八叛徒”创立“仙童”,仙童半导体公司发明“集成电路”,摩尔离开后创立Intel，“仙童”中另一成员桑德斯创立AMD<br>“摩尔定律”:每18个月性能翻倍</li>
</ul>
<h3 id="1-2-1-计算机硬件的基本组成"><a href="#1-2-1-计算机硬件的基本组成" class="headerlink" title="1.2.1 计算机硬件的基本组成"></a>1.2.1 计算机硬件的基本组成</h3><ol>
<li><strong>早期冯诺依曼机</strong><br>ENIAC（手动接线来控制计算）<br>冯诺依曼提出<strong>存储程序</strong>概念：<strong>将指令以二进制代码的形式事先输入计算机的主存储器</strong>，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束<br>——&gt;第一台采用冯诺依曼结构的计算机EDVAC<br><a target="_blank" rel="noopener" href="https://imgse.com/i/pVnkhQS"><img src="https://s21.ax1x.com/2025/06/28/pVnkhQS.png" alt="pVnkhQS.png"></a><ul>
<li><strong>冯诺依曼计算机的特点</strong></li>
</ul>
<ol>
<li>计算机由五大部件组成</li>
<li>指令和数据以同等地位存于存储器，可按地址寻访</li>
<li>指令和数据用二进制表示</li>
<li>指令由操作码和地址码组成</li>
<li>存储程序</li>
<li><strong>以运算器为中心</strong>（输入&#x2F;输出设备与存储器之间的数据传送通过运算器完成）</li>
</ol>
</li>
<li>现代计算机的结构<br> <a target="_blank" rel="noopener" href="https://imgse.com/i/pVnE841"><img src="https://s21.ax1x.com/2025/06/28/pVnE841.png" alt="pVnE841.png"></a><br>现代计算机：<strong>以存储器为中心</strong><br>CPU&#x3D;运算器+控制器<br><a target="_blank" rel="noopener" href="https://imgse.com/i/pVnEtgK"><img src="https://s21.ax1x.com/2025/06/28/pVnEtgK.png" alt="pVnEtgK.png"></a><ul>
<li>主存即内存</li>
<li>辅存：app存放在辅存，只有app启动运行后才会把相关代码程序数据读到主存</li>
</ul>
</li>
</ol>
<hr>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/pVnEyCt"><img src="https://s21.ax1x.com/2025/06/28/pVnEyCt.png" alt="pVnEyCt.png"></a></p>
<h3 id="1-2-2-各个硬件的工作原理"><a href="#1-2-2-各个硬件的工作原理" class="headerlink" title="1.2.2 各个硬件的工作原理"></a>1.2.2 各个硬件的工作原理</h3><ol>
<li><strong>主存储器的基本组成</strong><br>读操作：<br><a target="_blank" rel="noopener" href="https://imgse.com/i/pVnEz5R"><img src="https://s21.ax1x.com/2025/06/28/pVnEz5R.png" alt="pVnEz5R.png"></a><br>写操作：<br><a target="_blank" rel="noopener" href="https://imgse.com/i/pVnVpP1"><img src="https://s21.ax1x.com/2025/06/28/pVnVpP1.png" alt="pVnVpP1.png"></a><br><a target="_blank" rel="noopener" href="https://imgse.com/i/pVnVFKO"><img src="https://s21.ax1x.com/2025/06/28/pVnVFKO.png" alt="pVnVFKO.png"></a><br>存储体中存的是<strong>数据</strong>+<strong>指令（操作码+地址码）</strong></li>
<li><strong>运算器的基本组成</strong><br><img src="https://pic1.imgdb.cn/item/68b9bddc58cb8da5c87e9853.png"><br>ACC、MQ、X均为寄存器<br>核心部件为<strong>ALU</strong></li>
<li><strong>控制器的基本组成</strong><br><img src="https://pic1.imgdb.cn/item/68b9be0f58cb8da5c87e98a3.png"></li>
</ol>
<hr>
<ul>
<li><strong>计算机的工作过程</strong><br><img src="https://pic1.imgdb.cn/item/68bade2058cb8da5c880e482.png"><br><img src="https://pic1.imgdb.cn/item/68badf0458cb8da5c880e4e1.png"><br><img src="https://pic1.imgdb.cn/item/68badf2858cb8da5c880e4fd.png"><br><img src="https://pic1.imgdb.cn/item/68badfc958cb8da5c880e54c.png"><br><img src="https://pic1.imgdb.cn/item/68badfdc58cb8da5c880e55a.png"><br><img src="https://pic1.imgdb.cn/item/68bae00258cb8da5c880e565.png"></li>
</ul>
<hr>
<p><img src="https://pic1.imgdb.cn/item/68bae01558cb8da5c880e56d.png"></p>
<h3 id="1-2-3-计算机软件"><a href="#1-2-3-计算机软件" class="headerlink" title="1.2.3 计算机软件"></a>1.2.3 计算机软件</h3><p>软件&#x3D;系统软件+应用软件</p>
<ul>
<li><strong>三种级别的语言</strong><br>高级语言（源程序）-&gt;（通过编译程序（编译器））汇编语言（助记符）-&gt;（通过汇编程序（汇编器））机器语言（二进制代码）<ul>
<li>一些编程语言可以通过编译程序（编译器）<strong>直接</strong>将源程序翻译成机器语言</li>
<li>还有一些编程语言（JavaScript、Python、Shell）通过解释程序（解释器）将源程序翻译成机器语言<ul>
<li>编译程序：将高级语言编写的源程序<strong>全部</strong>语句<strong>一次全部</strong>翻译成机器语言程序，而后再执行机器语言程序（只需翻译一次）</li>
<li>解释程序：将源程序的一条语句翻译成对应于机器语言的语句，并立即执行。紧接着再翻译下一句（每次执行都要翻译）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>注：&#x3D;&#x3D;编译器、汇编器、解释器&#x3D;&#x3D;可统称“&#x3D;&#x3D;翻译程序&#x3D;&#x3D;”</p>
<ul>
<li><strong>软件和硬件的逻辑功能等价性</strong><br>同一个功能，既可以用硬件实现（性能高成本高），也可以用软件实现（性能低成本也低）<br>Eg：实现一个乘法，若硬件支持“乘法指令”，则可直接用硬件，若硬件只支持加法指令，则可用软件编写6条“加法指令”<ul>
<li><strong>指令集体系结构（ISA：Instruction Set Architecture）：</strong> 软件和硬件之间的界面（分界），设计计算机系统的ISA，就是要定义一台计算机可以支持哪些指令，以及每条指令的作用是什么，每条指令的用法是什么</li>
</ul>
</li>
</ul>
<h3 id="1-2-4-计算机系统的层次结构"><a href="#1-2-4-计算机系统的层次结构" class="headerlink" title="1.2.4 计算机系统的层次结构"></a>1.2.4 计算机系统的层次结构</h3><p><a target="_blank" rel="noopener" href="https://imgse.com/i/pVnwfpt"><img src="https://s21.ax1x.com/2025/06/29/pVnwfpt.png" alt="pVnwfpt.png"></a></p>
<h3 id="1-2-5-计算机系统的工作原理"><a href="#1-2-5-计算机系统的工作原理" class="headerlink" title="1.2.5 计算机系统的工作原理"></a>1.2.5 计算机系统的工作原理</h3><p><a target="_blank" rel="noopener" href="https://imgse.com/i/pVn0SnU"><img src="https://s21.ax1x.com/2025/06/29/pVn0SnU.png" alt="pVn0SnU.png"></a></p>
<h3 id="1-3-计算机的性能指标"><a href="#1-3-计算机的性能指标" class="headerlink" title="1.3 计算机的性能指标"></a>1.3 计算机的性能指标</h3><ol>
<li><p><strong>存储器的性能指标</strong><br><font color=red>总容量&#x3D;存储单元个数x存储字长 bit&#x3D;存储单元个数x存储字长&#x2F;8 Byte</font><br>Eg：MAR为32位，MDR为8位，总容量&#x3D;2的32次方*8 bit&#x3D;4GB</p>
</li>
<li><p><strong>CPU的性能指标</strong><br>Eg：翼龙15pro参数：<br>AMD Ryzen 7 8845H&#x2F;<strong>3.8GHz（CPU主频）</strong>&#x2F;八核十六线程</p>
<ul>
<li><strong>CPU主频</strong>：CPU内数字脉冲信号振荡的频率（单位：Hz）<br><strong>CPU主频（时钟频率）</strong>&#x3D;1&#x2F;CPU时钟周期（单位：微秒、纳秒）<br>每个动作至少要1个时钟周期</li>
<li><strong>CPI</strong>（Clock cycle Per Instruction）：执行一条指令所需的时钟周期数（不同的指令CPI不同，甚至相同的指令，CPI也可能有变化）</li>
<li><strong>执行一条指令的耗时</strong>&#x3D;CPIxCPU时钟周期</li>
<li><strong>CPU执行时间</strong>（整个程序的耗时）&#x3D;CPU时钟周期数&#x2F;主频&#x3D;（指令条数*CPI）&#x2F;主频</li>
<li><strong>IPS（KIPS、MIPS）</strong>（Instruction Per Second）：每秒执行多少条指令<br>IPS&#x3D;主频&#x2F;平均CPI</li>
<li><strong>FLOPS（KFLOPS、MFLOPS、GFLOPS、TFLOPS）</strong>（Floating-point Operation Per Second）：每秒执行多少次浮点运算<blockquote>
<p>注：此处K、M、G、T为数量单位，与KB、MB、GB不同</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>系统整体的性能指标</strong></p>
<ol>
<li>静态指标</li>
</ol>
<ul>
<li><strong>数据通路带宽</strong>：数据总线一次所能<strong>并行传送信息</strong>的位数（各硬件部件通过数据总线传输数据）</li>
<li><strong>吞吐量</strong>：指系统在单位时间内处理请求的数量</li>
<li><strong>响应时间</strong>：指从用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需要的结果的等待时间，通常包括CPU时间与等待时间</li>
</ul>
<ol start="2">
<li>动态指标<br><strong>基准程序（跑分软件）</strong>是用来测量计算机处理速度的一种实用程序，以便于被测量的计算机性能可以与运行相同程序的其它计算机性能进行比较</li>
</ol>
</li>
</ol>
<h2 id="二、数据的表示和运算"><a href="#二、数据的表示和运算" class="headerlink" title="二、数据的表示和运算"></a>二、数据的表示和运算</h2><h3 id="2-1-1-进位计数制"><a href="#2-1-1-进位计数制" class="headerlink" title="2.1.1 进位计数制"></a>2.1.1 进位计数制</h3><ul>
<li><strong>位权</strong><br><a target="_blank" rel="noopener" href="https://imgse.com/i/pVnB7Js"><img src="https://s21.ax1x.com/2025/06/29/pVnB7Js.png" alt="pVnB7Js.png"></a></li>
<li><strong>基数</strong> ：每个数码位所用到的不同符号的个数，r进制的基数为r<br><a target="_blank" rel="noopener" href="https://imgse.com/i/pVnDsmT"><img src="https://s21.ax1x.com/2025/06/29/pVnDsmT.png" alt="pVnDsmT.png"></a></li>
<li><strong>十进制-&gt;任意进制</strong><br>整数部分：除基取余<br>小数部分：乘基取整<br><a target="_blank" rel="noopener" href="https://imgse.com/i/pVnDy0U"><img src="https://s21.ax1x.com/2025/06/29/pVnDy0U.png" alt="pVnDy0U.png"></a></li>
<li><strong>真值和机器数（了解）</strong><br>真值：符合人类习惯的数字<br>机器数：数字实际存到机器里的形式，正负号需要被“数字化”</li>
</ul>
<h3 id="2-1-2-2-1-3-定点数的编码表示"><a href="#2-1-2-2-1-3-定点数的编码表示" class="headerlink" title="2.1.2+2.1.3 定点数的编码表示"></a>2.1.2+2.1.3 定点数的编码表示</h3><p>定点数：小数点的位置固定（Eg：996.007）<br>浮点数：小数点的位置不固定（Eg：9.96007*10的二次方——科学计数法）</p>
<ol>
<li><strong>无符号数的表示</strong><br>无符号数：整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的绝对值<br>n位无符号数<strong>表示范围</strong>为：0~2的n次方-1<blockquote>
<p>通常只有无符号数整数，而没有无符号数小数（unsigned float报错）</p>
</blockquote>
</li>
<li><strong>有符号数的定点表示</strong><br>最高位为符号位（0正1负），其余为数值部分（尾数）<br>注：可用<strong>原码、反码、补码</strong>三种方式来表示定点整数和定点小数。还可用<strong>移码</strong>表示定点整数<br><a target="_blank" rel="noopener" href="https://imgse.com/i/pVnDonK"><img src="https://s21.ax1x.com/2025/06/29/pVnDonK.png" alt="pVnDonK.png"></a><ol>
<li><strong>原码</strong><br><a target="_blank" rel="noopener" href="https://imgse.com/i/pVnD77D"><img src="https://s21.ax1x.com/2025/06/29/pVnD77D.png" alt="pVnD77D.png"></a><br><a target="_blank" rel="noopener" href="https://imgse.com/i/pVnDbAe"><img src="https://s21.ax1x.com/2025/06/29/pVnDbAe.png" alt="pVnDbAe.png"></a><br>由于真值0有+0和-0两种形式，实际只能表示2的n+1次方-1个数</li>
<li><strong>反码</strong><br>若符号位为0，则反码与原码相同<br><strong>若符号位为1，则数值位全部取反</strong><br>反码的表示范围与原码对应<br>注：“反码”只是“原码”转变为“补码”的一个中间状态 </li>
<li><strong>补码</strong><br>正数的补码&#x3D;原码<br>负数的补码&#x3D;反码末位+1（要考虑进位）<br>  <img src="https://pic1.imgdb.cn/item/68bae18158cb8da5c880e63e.png"></li>
<li><strong>移码</strong><br>补码的基础上将符号位取反<br><strong>注意：移码只能用于表示整数</strong><br>移码的表示范围与补码对应<br>移码作用：真值越大，移码对应的无符号数也在逐一递增，因此，移码表示的整数很方便对比大小（从高位开始对比，谁先出现1谁更大）</li>
</ol>
</li>
</ol>
<p>技巧：由[x]补k快速求[-x]补的方法：符号位、数值位全部取反，末位+1<br>3. <strong>各种码的作用</strong>（拓展）</p>
<ol>
<li>加减运算</li>
</ol>
<ul>
<li>若使用原码进行加减运算，正+负要变为正-正，否则结果错误</li>
<li>加法——用加法器完成<br> 减法——用减法器完成<br>减法器成本高，能否用加法代替减法？</li>
</ul>
<ol start="2">
<li>用加法代替减法<br>   Eg：-3和+9在mod 12时等价<blockquote>
<p>数论中余数定义：带余除法——设x，m属于z，m&gt;0则存在唯一决定的整数q和r，使得：x&#x3D;qm+r，0&lt;&#x3D;r&gt;m</p>
</blockquote>
</li>
</ol>
<p>   根据该定义，-3 mod 12&#x3D;9<br>   （mod 12）把所有整数分为12类<br>   在（mod m）的条件下，若能找到负数的补数，就可以用正数的加法来等价替代减法<br>   &#x3D;&#x3D;模-a的绝对值&#x3D;a的补数（补码）&#x3D;&#x3D;<br>   计算机硬件默认完成mod 2的8次方操作</p>
<ul>
<li>补码的作用：使用补码可将减法操作转变为等价的加法，ALU中无需集成减法器。执行加法操作时，符号位一起参与运算</li>
<li>移码的作用：移码表示的整数很方便对比大小</li>
</ul>
<h3 id="2-1-4-1-C语言中的整数类型及类型转换"><a href="#2-1-4-1-C语言中的整数类型及类型转换" class="headerlink" title="2.1.4_1 C语言中的整数类型及类型转换"></a>2.1.4_1 C语言中的整数类型及类型转换</h3><p><img src="https://pic1.imgdb.cn/item/68bae0ee58cb8da5c880e5aa.png"></p>
<h3 id="2-1-4-1-零扩展、符号扩展"><a href="#2-1-4-1-零扩展、符号扩展" class="headerlink" title="2.1.4_1 零扩展、符号扩展"></a>2.1.4_1 零扩展、符号扩展</h3><p>为什么要对数据进行长度扩展？</p>
<ul>
<li>机器字长（Eg：32位）决定通用寄存器位数，因此通用寄存器位数是固定的</li>
<li>ALU的位数是固定的，运算前可能需要把短数据扩展为长数据</li>
</ul>
<ol>
<li><strong>零扩展</strong><br><strong>适用于无符号整数</strong>，用0扩展高位</li>
<li><strong>符号扩展</strong><br>计算机中带符号整数是以补码的形式存储的<br><strong>适用于带符号整数（补码）</strong>，用“符号位”扩展高位（补的位与符号位数值相同）</li>
</ol>
<h3 id="2-2-0-1-逻辑门电路（数字电路基础补充）"><a href="#2-2-0-1-逻辑门电路（数字电路基础补充）" class="headerlink" title="2.2.0_1 逻辑门电路（数字电路基础补充）"></a>2.2.0_1 逻辑门电路（数字电路基础补充）</h3><ul>
<li><strong>基本逻辑运算</strong><ol>
<li><strong>与</strong><br> <img src="https://pic1.imgdb.cn/item/68bae25558cb8da5c880e6ea.png"></li>
<li><strong>或</strong><br> <img src="https://pic1.imgdb.cn/item/68bae27e58cb8da5c880e706.png"></li>
<li><strong>非</strong><br> <img src="https://pic1.imgdb.cn/item/68bae2a358cb8da5c880e71c.png"></li>
</ol>
</li>
<li><strong>复合逻辑运算</strong><ol>
<li><strong>与非</strong><br> <img src="https://pic1.imgdb.cn/item/68bae30658cb8da5c880e776.png"></li>
<li><strong>或非</strong><br> <img src="https://pic1.imgdb.cn/item/68bae31a58cb8da5c880e7be.png"></li>
<li><strong>异或</strong><br> <img src="https://pic1.imgdb.cn/item/68bae39358cb8da5c880e85a.png"></li>
<li><strong>同或</strong><br> <img src="https://pic1.imgdb.cn/item/68bae3bc58cb8da5c880e871.png"></li>
</ol>
</li>
</ul>
<h2 id="补充1：门电路的变形画法-补充2：逻辑运算的优先级、常见公式"><a href="#补充1：门电路的变形画法-补充2：逻辑运算的优先级、常见公式" class="headerlink" title="- 补充1：门电路的变形画法- 补充2：逻辑运算的优先级、常见公式"></a><img src="https://pic1.imgdb.cn/item/68bae3f958cb8da5c880e8f9.png"><br>- <strong>补充1：门电路的变形画法</strong><br><img src="https://pic1.imgdb.cn/item/68bae44458cb8da5c880e968.png"><br>- <strong>补充2：逻辑运算的优先级、常见公式</strong><br><img src="https://pic1.imgdb.cn/item/68bae48458cb8da5c880e9c5.png"></h2><ul>
<li><strong>拓展：芯片制程</strong><br><img src="https://pic1.imgdb.cn/item/68bae7cd58cb8da5c880ec9d.png"><br><img src="https://pic1.imgdb.cn/item/68bae3d358cb8da5c880e89c.png"></li>
</ul>
<h3 id="2-2-0-2-多路选择器、三态门（数字电路基础补充）"><a href="#2-2-0-2-多路选择器、三态门（数字电路基础补充）" class="headerlink" title="2.2.0_2 多路选择器、三态门（数字电路基础补充）"></a>2.2.0_2 多路选择器、三态门（数字电路基础补充）</h3><ul>
<li><strong>多路选择器（MUX）</strong><br><img src="https://pic1.imgdb.cn/item/68bae84558cb8da5c880ecf7.png"><br><img src="https://pic1.imgdb.cn/item/68bae86058cb8da5c880ed3d.png"></li>
<li><strong>三态门</strong><br><img src="https://pic1.imgdb.cn/item/68bae8b858cb8da5c880ee1b.png"><br><code>三态门和非门核心区别：“非门”没有控制信号！只有输入和输出</code><br>若多路选择器有k个输入，则控制信号的位数m&gt;&#x3D;[log2(k)]（向上取整）bit<br>有的多路选择器可能会预留一个控制信号，用于拦截所有输入，此时控制信号的位数m&gt;&#x3D;[log2(k+1)]（向上取整）bit</li>
</ul>
<h3 id="2-2-1-1-加法器"><a href="#2-2-1-1-加法器" class="headerlink" title="2.2.1_1 加法器"></a>2.2.1_1 加法器</h3><ul>
<li><strong>如何用门电路实现一位加法</strong><br><img src="https://pic1.imgdb.cn/item/68baeca458cb8da5c880f2f0.png"></li>
<li><strong>一位全加器</strong><br><img src="https://pic1.imgdb.cn/item/68baecc158cb8da5c880f315.png"></li>
<li><strong>n bit加法器</strong><br><img src="https://pic1.imgdb.cn/item/68baecdf58cb8da5c880f332.png"></li>
<li><strong>不足之处</strong><br><img src="https://pic1.imgdb.cn/item/68baeda658cb8da5c880f448.png"><br>由于两个输入端允许<font color=lightblue>并行输入 n bit</font>,因此这种加法器属于：<font color=lightblue>并行加法器</font><br>由于<font color=red>进位信息是串行产生的</font>，因此从“进位方式”看，这种加法器属于：<font color=red>串行进位加法器</font><br>综上，很多教材把这种加法器称为“<code>串行进位的并行加法器</code>”</li>
<li><strong>并行进位的并行加法器</strong><br><img src="https://pic1.imgdb.cn/item/68baef2d58cb8da5c880f778.png"></li>
<li><strong>带标志位的加法器</strong><br><img src="https://pic1.imgdb.cn/item/68baef6e58cb8da5c880f7f7.png"></li>
<li><strong>标志位的生成</strong><br><img src="https://pic1.imgdb.cn/item/68baefc458cb8da5c880f8b7.png"></li>
</ul>
<h3 id="2-2-1-3-算术逻辑单元ALU"><a href="#2-2-1-3-算术逻辑单元ALU" class="headerlink" title="2.2.1_3 算术逻辑单元ALU"></a>2.2.1_3 算术逻辑单元ALU</h3><ul>
<li><strong>算术逻辑单元（ALU）的作用</strong><br>CPU由控制器、运算器组成<br><font color=lightblue>控制器负责解析指令</font>，并根据指令功能发出相应的控制信号（将在计组第五章详细学习）<br><font color=lightblue>运算器负责对数据进行处理</font>，如：加减乘除等<br>ALU是一种组合逻辑电路，实现了加减乘除与或非等功能。因此<font color=red>ALU是运算器的核心</font><br>由于加减乘除等运算都要基于“加法”来实现，因此<font color=red>加法器是ALU的核心</font></li>
<li><strong>ALU的功能</strong><br><img src="https://pic1.imgdb.cn/item/68be3db658cb8da5c8875d63.png"></li>
<li><strong>ALU的实现原理</strong>（简单了解即可）<br><img src="https://pic1.imgdb.cn/item/68be3e3258cb8da5c8875da2.png"></li>
<li><strong>看懂ALU图示</strong><br><img src="https://pic1.imgdb.cn/item/68be3ed758cb8da5c8875df3.png"></li>
</ul>
<hr>
<p><img src="https://pic1.imgdb.cn/item/68be3eea58cb8da5c8875df8.png"></p>
<h3 id="2-2-2-定点数的移位运算"><a href="#2-2-2-定点数的移位运算" class="headerlink" title="2.2.2 定点数的移位运算"></a>2.2.2 定点数的移位运算</h3><ul>
<li><strong>逻辑移位（常用于处理无符号整数）</strong><ul>
<li>逻辑左移：<code>高位移出丢弃，低位补0</code><br> 对于<strong>无符号整数</strong>，每逻辑<strong>左</strong>移一位，则相当于×2<br> 注意：若逻辑<strong>左</strong>移丢弃的位&#x3D;1，则发生<code>溢出</code>（<strong>超出n bit无符号整数的表示范围</strong>）</li>
<li>逻辑右移：<code>低位移出丢弃，高位补0</code><br> 对于<strong>无符号整数</strong>，每逻辑<strong>右</strong>移一位，则相当于÷2<br> 注意：若逻辑<strong>右</strong>移丢弃的位&#x3D;1，则会<code>丢失精度</code></li>
</ul>
</li>
<li><strong>算数移位（常用于处理带符号整数）</strong><ul>
<li>算数左移：<code>高位移出丢弃，低位补0</code><br> 对于<strong>带符号整数</strong>，每算数<strong>左</strong>移一位，则相当于×2<br> 注意：若算数<strong>左</strong>移前后的<code>符号位不同</code>，则发生<code>溢出</code>（<strong>超出n bit带符号整数的表示范围</strong>）<br> <img src="https://pic1.imgdb.cn/item/68be412358cb8da5c8875f03.png"></li>
<li>算数右移：<code>低位移出丢弃，高位补符号位</code><br> 对于<strong>带符号整数</strong>，每算数<strong>右</strong>移一位，则相当于÷2<br> 注意：若算数<strong>右</strong>移丢弃的位&#x3D;1，则会<code>丢失精度</code></li>
</ul>
</li>
</ul>
<h3 id="2-2-3-1-定点数的加减运算"><a href="#2-2-3-1-定点数的加减运算" class="headerlink" title="2.2.3_1 定点数的加减运算"></a>2.2.3_1 定点数的加减运算</h3><ul>
<li><strong>原码的加减运算</strong><br><img src="https://pic1.imgdb.cn/item/68be425558cb8da5c8875f3d.png"></li>
<li><strong>补码的加减运算</strong><br><img src="https://pic1.imgdb.cn/item/68be44a758cb8da5c88769b3.png"></li>
<li><h2 id="溢出判断-1-方法一-2-方法二-3-方法三"><a href="#溢出判断-1-方法一-2-方法二-3-方法三" class="headerlink" title="溢出判断 1. 方法一  2. 方法二  3. 方法三 "></a><strong>溢出判断</strong><br><img src="https://pic1.imgdb.cn/item/68be458158cb8da5c88769eb.png"><br> 1. <strong>方法一</strong><br> <img src="https://pic1.imgdb.cn/item/68be45ad58cb8da5c88769fe.png"><br> 2. <strong>方法二</strong><br> <img src="https://pic1.imgdb.cn/item/68be461158cb8da5c8876a21.png"><br> 3. <strong>方法三</strong><br> <img src="https://pic1.imgdb.cn/item/68be46a258cb8da5c8876a67.png"></h2> <img src="https://pic1.imgdb.cn/item/68be46b358cb8da5c8876a6f.png"></li>
</ul>
<h3 id="2-2-3-2-无符号数的加减运算"><a href="#2-2-3-2-无符号数的加减运算" class="headerlink" title="2.2.3_2 无符号数的加减运算"></a>2.2.3_2 无符号数的加减运算</h3><ul>
<li><strong>无符号数的加法运算</strong><br><img src="https://pic1.imgdb.cn/item/68be485f58cb8da5c8876b28.png"></li>
<li><strong>无符号数的减法运算</strong><br><img src="https://pic1.imgdb.cn/item/68be482158cb8da5c8876b15.png"></li>
<li><strong>无符号数加法&#x2F;减法的溢出判断</strong><br>无符号数<font color=red>加法</font>的溢出判断：<font color=red>最高位产生的进位&#x3D;1时，发生溢出，否则未溢出</font><br>无符号数<font color=blue>减法</font>的溢出判断：<font color=blue>最高位产生的进位&#x3D;0时，发生溢出，否则未溢出</font></li>
</ul>
<h3 id="2-2-3-3-补码加减运算电路"><a href="#2-2-3-3-补码加减运算电路" class="headerlink" title="2.2.3_3 补码加减运算电路"></a>2.2.3_3 补码加减运算电路</h3><ul>
<li><strong>补码加减运算电路</strong><br><img src="https://pic1.imgdb.cn/item/68be4b3158cb8da5c8876cff.png"><blockquote>
<p>也可用于计算无符号数加减运算</p>
</blockquote>
</li>
</ul>
<h3 id="2-2-4-1-无符号整数的乘法运算原理"><a href="#2-2-4-1-无符号整数的乘法运算原理" class="headerlink" title="2.2.4_1 无符号整数的乘法运算原理"></a>2.2.4_1 无符号整数的乘法运算原理</h3><ul>
<li><strong>以4bit无符号整数为例</strong><br><img src="https://pic1.imgdb.cn/item/68be4cd358cb8da5c8876da8.png"><br><img src="https://pic1.imgdb.cn/item/68be4d2b58cb8da5c8876dca.png"><br><img src="https://pic1.imgdb.cn/item/68be4da458cb8da5c8876dfc.png"></li>
<li><strong>无符号整数乘法原理：溢出判断、溢出处理</strong><br><img src="https://pic1.imgdb.cn/item/68be4dcf58cb8da5c8876e09.png"></li>
<li><strong>32位无符号数乘法运算电路的结构</strong><br><img src="https://pic1.imgdb.cn/item/68be4e1258cb8da5c8876e1f.png"></li>
</ul>
<h3 id="2-2-4-2-带符号整数的乘法运算原理"><a href="#2-2-4-2-带符号整数的乘法运算原理" class="headerlink" title="2.2.4_2 带符号整数的乘法运算原理"></a>2.2.4_2 带符号整数的乘法运算原理</h3><ul>
<li><strong>以4bit带符号整数为例</strong><br><img src="https://pic1.imgdb.cn/item/68be4e7e58cb8da5c8876e34.png"><br><img src="https://pic1.imgdb.cn/item/68be4efc58cb8da5c8876e56.png"><blockquote>
<p>注意是进行算数右移，不是逻辑右移</p>
</blockquote>
</li>
</ul>
<p><img src="https://pic1.imgdb.cn/item/68be4fb658cb8da5c8876e90.png"></p>
<ul>
<li><p><strong>带符号整数乘法原理：溢出判断、溢出处理</strong><br><img src="https://pic1.imgdb.cn/item/68be507b58cb8da5c8876ee4.png"></p>
<blockquote>
<p>为何是OF标志位不是CF标志位？<br>CF标志位一般用来记录加减运算的溢出情况，乘法运算的溢出情况都是用OF标志位</p>
</blockquote>
</li>
<li><p><strong>32位带符号数乘法运算电路的结构</strong><br><img src="https://pic1.imgdb.cn/item/68be50f858cb8da5c8876f04.png"></p>
</li>
</ul>
<hr>
<p>补充：本节介绍的<code>“补码一位乘法”</code>由A.D.Booth提出，因此这种算法也被称为<code>布斯（Booth）乘法</code></p>
<h3 id="2-2-4-3-计算机实现乘法运算的三种方式"><a href="#2-2-4-3-计算机实现乘法运算的三种方式" class="headerlink" title="2.2.4_3 计算机实现乘法运算的三种方式"></a>2.2.4_3 计算机实现乘法运算的三种方式</h3><ol>
<li><p><strong>由ALU、移位器、寄存器、控制逻辑组成的乘法电路</strong><br><img src="https://pic1.imgdb.cn/item/68be526258cb8da5c8876f78.png"></p>
</li>
<li><p><strong>阵列乘法器</strong><br><img src="https://pic1.imgdb.cn/item/68be528c58cb8da5c8876f83.png"></p>
<blockquote>
<p><u>阵列乘法器</u>是<u>快速乘法器</u>中的一种。很多“<u>快速乘法器</u>”都可以在1个时钟内完成乘法运算</p>
</blockquote>
</li>
<li><p><strong>用逻辑运算、加&#x2F;减运算（软件）等效实现乘法</strong><br><img src="https://pic1.imgdb.cn/item/68be535658cb8da5c8876fd6.png"></p>
</li>
</ol>
<hr>
<ul>
<li><strong>结论（小题、简答题常考）</strong><br><img src="https://pic1.imgdb.cn/item/68be539c58cb8da5c8876fe8.png"></li>
</ul>
<h3 id="2-2-4-4-无符号整数的除法运算原理"><a href="#2-2-4-4-无符号整数的除法运算原理" class="headerlink" title="2.2.4_4 无符号整数的除法运算原理"></a>2.2.4_4 无符号整数的除法运算原理</h3><ul>
<li><strong>以4bit无符号整数为例</strong><br><img src="https://pic1.imgdb.cn/item/68be543458cb8da5c8877014.png"><br><img src="https://pic1.imgdb.cn/item/68be551258cb8da5c8877049.png"><br>R-Y的值要先存入余数寄存器R中，要恢复成R时再加上Y即可<br><img src="https://pic1.imgdb.cn/item/68be558f58cb8da5c8877099.png"><br><img src="https://pic1.imgdb.cn/item/68be55a958cb8da5c88770a4.png"></li>
<li><strong>32位无符号数除法运算电路的结构</strong><br><img src="https://pic1.imgdb.cn/item/68be55c658cb8da5c88770a8.png"></li>
<li><strong>关于“商溢出”的进一步探讨</strong><br><img src="https://pic1.imgdb.cn/item/68be561058cb8da5c88770b7.png"></li>
</ul>
<hr>
<p>概念补充：在x86中，<u>除数为0</u>，<u>商溢出</u>都属于<code>“除法错异常”</code>（Divide Error Exception），也可简译为<code>“除法异常”</code></p>
<h3 id="2-3-1-1-浮点数的表示-IEEE-754"><a href="#2-3-1-1-浮点数的表示-IEEE-754" class="headerlink" title="2.3.1_1 浮点数的表示_IEEE 754"></a>2.3.1_1 浮点数的表示_IEEE 754</h3><p><img src="https://pic1.imgdb.cn/item/68be6d4e58cb8da5c88785e0.png"></p>
<ul>
<li><strong>从科学计数法理解浮点数</strong><br><img src="https://pic1.imgdb.cn/item/68be6e5458cb8da5c8878dbf.png"><br>尾数“规格化”的好处：便于在计算机内部存储</li>
<li><strong>IEEE 754标准定义的浮点数格式</strong><br><img src="https://pic1.imgdb.cn/item/68be6f6f58cb8da5c8878efc.png"></li>
<li><strong>float单精度浮点型的存储</strong><br><img src="https://pic1.imgdb.cn/item/68be709858cb8da5c8878fb9.png"></li>
<li><strong>double双精度浮点型的存储</strong><br><img src="https://pic1.imgdb.cn/item/68be70fc58cb8da5c8878fde.png"></li>
</ul>
<h3 id="2-3-1-3-浮点数的表示范围、几种特殊状态"><a href="#2-3-1-3-浮点数的表示范围、几种特殊状态" class="headerlink" title="2.3.1_3 浮点数的表示范围、几种特殊状态"></a>2.3.1_3 浮点数的表示范围、几种特殊状态</h3><h2 id="IEEE：规格化浮点数的表示范围-IEEE：浮点数的上溢（Overflow）-IEEE：无穷大的表示-IEEE-754：浮点数的下溢（Underflow）-IEEE-754：真值0的表示-IEEE-754：非规格化浮点数的表示负数符号取反即可-IEEE-754：非数（NaN）的表示"><a href="#IEEE：规格化浮点数的表示范围-IEEE：浮点数的上溢（Overflow）-IEEE：无穷大的表示-IEEE-754：浮点数的下溢（Underflow）-IEEE-754：真值0的表示-IEEE-754：非规格化浮点数的表示负数符号取反即可-IEEE-754：非数（NaN）的表示" class="headerlink" title="- IEEE：规格化浮点数的表示范围- IEEE：浮点数的上溢（Overflow）- IEEE：无穷大的表示- IEEE 754：浮点数的下溢（Underflow）- IEEE 754：真值0的表示- IEEE 754：非规格化浮点数的表示负数符号取反即可- IEEE 754：非数（NaN）的表示"></a><img src="https://pic1.imgdb.cn/item/68be717c58cb8da5c887905c.png"><br>- <strong>IEEE：<u>规格化浮点数</u>的表示范围</strong><br><img src="https://pic1.imgdb.cn/item/68be722f58cb8da5c8879186.png"><br><img src="https://pic1.imgdb.cn/item/68be72c158cb8da5c887929e.png"><br>- <strong>IEEE：浮点数的上溢（Overflow）</strong><br><img src="https://pic1.imgdb.cn/item/68be73d858cb8da5c8879423.png"><br>- <strong>IEEE：无穷大的表示</strong><br><img src="https://pic1.imgdb.cn/item/68be73b158cb8da5c88793ed.png"><br>- <strong>IEEE 754：浮点数的下溢（Underflow）</strong><br><img src="https://pic1.imgdb.cn/item/68be744858cb8da5c8879494.png"><br>- <strong>IEEE 754：真值0的表示</strong><br><img src="https://pic1.imgdb.cn/item/68be759c58cb8da5c8879af7.png"><br>- <strong>IEEE 754：非规格化浮点数的表示</strong><br><img src="https://pic1.imgdb.cn/item/68be761358cb8da5c8879e5f.png"><br>负数符号取反即可<br>- <strong>IEEE 754：非数（NaN）的表示</strong><br><img src="https://pic1.imgdb.cn/item/68be76d158cb8da5c887a3a8.png"></h2><p><img src="https://pic1.imgdb.cn/item/68be76eb58cb8da5c887a4a8.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" data-id="cmh7rsi3000026kuvco1a6njq" data-title="计算机组成原理" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/10/">October 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/09/">September 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/10/26/java/">Java</a>
          </li>
        
          <li>
            <a href="/2025/10/13/web%E5%BC%80%E5%8F%91/">web开发</a>
          </li>
        
          <li>
            <a href="/2025/09/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
          </li>
        
          <li>
            <a href="/2025/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>