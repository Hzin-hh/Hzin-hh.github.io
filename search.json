[{"title":"mysql","url":"/2025/10/30/mysql/","content":"MySQL数据模型MySQL实际上是一个数据库管理系统\n语法MySQL中字符串类型为varchar(字符串长度)SQL语句以分号结尾注释：COMMENT还可加IF EXIST等\nDDL\n数据库操作  SHOW DATABASES;CREATE DATABASE 数据库名;USE 数据库名;SELECT DATABASE();DROP DATABASE 数据库名\n表操作  SHOW TABLES;CREATE TABLE 表名(字段 字段类型，字段 字段类型);DESC 表名;SHOW CREATE TABLE 表名;ALTER TABLE 表名 ADD/MODIFY/CHANGE/DROP/RENAME TO...;DROP TABLE 表名;\n\nDML\n添加数据\n给指定字段添加数据 INSERT INTO 表名(字段1,字段2,...) VALUES(值1,值2,...);\n给全部字段添加数据INSERT INTO 表名 VALUES(值1,值2,...);\n批量添加数据INSERT INTO 表名(字段名1,字段名2,...) VALUES(值1,值2,...),(值1,值2,...),(值1,值2,...);``````sqlINSERT INTO 表名 VALUES(值1,值2,...),(值1,值2,...),(值1,值2,...);\n\n\n修改数据 UPDATE 表名 SET 字段1=值1,字段2=值2 [WHERE 条件];\n删除数据 DELETE FROM 表名 [WHERE 条件];\n\nDQLSELECT    字段列表    (字段名[AS]别名)FROM    表名WHERE    条件列表    (&gt; &gt;= &lt;= = &lt;&gt; like between...and in and or)(分组之前过滤)GROUP BY    分组字段列表HAVING    分组后条件列表  (分组之后过滤)ORDER BY    排序字段列表    (升序ASC,降序DESC)LIMIT    分页参数    (起始索引(从0开始)，每页展示记录数)\n`SELECT *`：表示查询所有字段信息`like`：_ or %，_只能表示一位`(name like &#x27;_ _ _&#x27;)`：%能表示所有位数`SELECT A,B FORM...`：查询出的列表列分别就为A和B`LIMIT`：起始索引从0开始，起始索引=(查询页码-1)*每页显示记录数(如果查询的是第一页数据，起始索引可以省略，直接简写为limit 10)`SELECT DISTINCT...`：查询结果去重- **DQL执行顺序**![](https://pic1.imgdb.cn/item/6904a4e63203f7be00ba6329.png)### DCL- **用户管理**    ```sql    CREATE USER  &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED BY &#x27;密码&#x27;;    ALTER USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;密码&#x27;;    DROP USER &#x27;用户名&#x27;@&#x27;主机名&#x27;\n\n权限控制  GRANT 权限列表 ON 数据库名.表名 TO &#x27;用户名&#x27;@&#x27;主机名&#x27;;REVOKE 权限列表 ON 数据库名.表名 FROM &#x27;用户名&#x27;@&#x27;主机名&#x27;;\n  \n\n函数字符串函数\n数值函数\n日期函数\n流程函数\n约束\n概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据\n目的：保证数据库中数据的正确、有效性和完整性\n分类：\n\n外键约束\n概念外键用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性\n语法添加外键  CREATE TABLE 表名(    字段名 数据类型;    ...    [CONSTRANT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名));\n  ALTER TABLE 表名 ADD CONSTRANT 外键名称 FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名)\n  外键名称：fk_表名_字段名删除外键ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;\n外键删除&#x2F;更新行为    &#96;ALTER TABLE 表名 ADD CONSTRANT 外键名称 FOREIGN KEY(外键字段) REFERENCES 主表名(主表字段名) ON UPDATE CASCADE ON DELETE CASCADE\n\n多表查询\n概述：指从多张表中查询数据\n笛卡尔积：笛卡尔乘积是指在数学中，两个集合A集合和B集合的所有组合情况。(在多表查询时，需要消除无效的笛卡尔积)select * from emp , dept where emp.dept_id=dept.id\n多表关系\n多表查询分类\n\n连接查询内连接\n隐式内连接  SELECT 字段列表 FROM 表1,表2 WHERE 条件...;\n显式内连接  SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件...;\n\n外连接\n左外连接  SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 连接条件...;\n右外连接  SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 连接条件...;\n\n自连接SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件...;\n自连接查询，可以是内连接查询，也可以是外连接查询\n联合查询-union，union allSELECT 字段列表 FROM 表A...UNION [ALL]SELECT 字段列表 FROM 表B...;\n对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致\n子查询\n列子查询\n行子查询\n表子查询\n事务事务是一组操作的集合，这组操作，要么全部执行成功，要么全部执行失败默认MySQL的事务是自动提交的，也就是说，当执行一条DML语句，MySQL会立即隐式地提交事务\n事务操作方式一\n查看&#x2F;设置事务提交方式  SELECT @@autocommit;SET @@autocommit=0;\n提交事务  COMMIT;\n回滚事务  ROLLBACK;\n\n方式二\n开启事务  START TRANSACTION 或 BEGIN;\n提交事务  COMMIT;\n回滚事务  ROLLBACK;\n\n事务四大特性（ACID）\n原子性（Atomicity）  事务是不可分割的最小操作单元，要么全部成功，要么全部失败\n一致性（Consistency）  事务完成时，必须使所有的数据都保持一致状态\n隔离性（Isolation）  数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行\n持久性（Durability）  事务一旦提交或回滚，它对数据库中的数据的改变就是永久的\n\n并发事务问题\n脏读  一个事务读到另一个事务还没有提交的数据  \n不可重复读  一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读  \n幻读  一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在（再次查还是查不到，因为已经解决不可重复读问题），好像出现了‘幻影’  \n\n事务隔离级别Oracle的默认级别是Read committed\n-- 查看事务隔离级别SELECT @@TRANSACTION_ISOLATION;-- 设置事务隔离级别SET [SESSION | GLOBAL] TRANSACTION ISOLATON LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE&#125;\n注意：事务隔离级别越高，数据越安全，但是性能越低\n存储引擎MySQL体系结构\n存储引擎简介存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被成为表类型\n\n在创建表时，指定存储引擎 CREATE TABLE 表名(    字段1 字段1类型 [COMMENT 字段1注释],    ......    字段n 字段n类型 [COMMENT 字段n注释])ENGINE=INNODB [COMMENT 表注释]\n查看当前数据库支持的存储引擎SHOW ENGINES;\n\n存储引擎特点\nInnoDB\n\n介绍：  InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在MySQL5.5之后，InnoDB是默认的MySQL存储引擎\n特点  DML操作遵循ACID模型，支持事务；  行级锁，提高并发访问性能；  支持外键FOREIGN KEY约束，保证数据的完整性和正确性；\n文件  xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm（早期）、sdi）、数据和索引。  参数：innodb_file_per_table（默认打开，表示每张表对应一个表空间文件）\n逻辑存储结构  \n\n\nMyISAM\n\n介绍：  MyISAM是MySQL早期的默认存储引擎\n特点  不支持事务，不支持外键  支持表锁，不支持行锁  访问速度快\n文件  xxx.sdi：存储表结构  xxx.MYD：存储数据  xxx.MYI：存储索引\n\n\nMemory\n\n介绍：  Memory引擎的表数据是存储在内存中的，由于受到硬件问题，或断电问题的影响，只能将这些表作为临时表或缓存使用\n特点  内存存放  hash索引（默认）\n文件  xxx.sdi：存储表结构信息\n\n\n\n\n存储引擎选择在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合\n\n\nInnoDB  是MySQL的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择\nMyISAM  如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的\nMemory  将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性\n\n索引索引概述索引（index）是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。\n\n优势  提高数据检索的效率，降低数据库的IO成本  通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗\n劣势  索引列也是要占用空间的  索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低\n\n索引结构MySQL的索引实在存储引擎曾实现的，不同的存储引擎有不同的结构，主要包含以下几种我们平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引\n\n思考：为什么InnoDB存储引擎选择使用B+tree索引结构？\n\n相对于二叉树，层级更少，搜索效率高\n对于B树，无论是叶子结点还是非叶子结点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低\n相对Hash索引，B+树支持范围匹配和排序操作\n\n索引分类聚集索引选取规则- 如果存在主键，主键索引就是聚集索引- 如果不存在主键，将使用第一个（UNIQUE）索引作为聚集索引- 如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引&gt; 聚集索引叶子结点下面挂的是一行的数据&gt; 二级索引叶子结点下面挂的是聚集索引思考：InnoDB主键索引的B+tree高度为多高？\n索引语法\n创建索引  CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name(index_col_name,...);\n查看索引  SHOW INDEX FROM table_name;\n删除索引  DROP INDEX index_name ON table_name;\n\nSQL性能分析\nSQL执行频率  MySQL客户端连接成功后，通过show [session|global] status 命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次：  SHOW GLOBAL STATUS LIKE &#39;Com   _______&#39;(7个_)\n慢查询日志  慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志  MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：  # 开启MySQL慢日志查询开关slow_query_log=1# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志long_query_time=2\n  配置完毕之后，通过以下指令重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;localhost-slow.log\nprofile详情\nshow profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling参数，能够看到当前MySQL是否支持profile操作  SELECT @@have_profiling;\n默认profiling是关闭的，可以通过set语句在session&#x2F;global级别开启profiling；  SET profiling=1;\n执行一系列的业务SQL的操作，然后通过如下指令查看指令的执行耗时  #查看每一条SQL的耗时基本情况show profiles;#查看指定query_id的SQL语句各个阶段的耗时情况show profile for query query_id#查看指定query_id的SQL语句CPU的使用情况show profile cpu for query query_id;\n\n\nexplain执行计划\nEXPLAIN或者DESC命令获取MySQL如何执行SELECT语句的信息，包括在SELECT语句执行过程中表如何连接和连接的顺序  语法：  #直接在select语句之前加上关键字explain/descEXPLAIN SELECT 字段列表  FROM 表名 WHERE 条件;\nEXPLAIN执行计划各字段含义：\nid  select查询的序列号，表示查询中执行select子句或者是操作表的顺序（id相同，执行顺序从上到下；id不同，值越大，越先执行）\nselect_type  表示SELECT的类型，常见的取值有SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT&#x2F;WHERE之后包含了子查询）等\ntype  表示连接类型，性能由好到差的连接类型为NULL（不查询具体的表）、system（访问系统表）、const（根据主键&#x2F;唯一索引进行访问）、eq_ref、ref（使用非唯一索引进行查询）、range、index、all\npossible_key  显示可能应用在这张表上的索引，一个或多个\nKey  实际使用的索引，如果为NULL，则没有使用索引\nKey_len  表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好\nrows  MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的\nfiltered  表示返回结果的行数占需读取行数的百分比，filtered的值越大越好\n\n\n\n\n\n索引使用规则\n最左前缀法则  如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列  如果跳跃某一列，索引将部分失效（后面的字段索引失效）\n最左边的字段必须存在，但是顺序可以互换\n\n\n范围查询  联合索引中，出现范围查询（&gt;,&lt;），范围查询右侧的列索引失效\n最好用&gt;&#x3D;、&lt;&#x3D;\n\n\n索引列运算  不要在索引列上进行运算操作，索引将失效  explain select * from tb_user where substring(phone,10,2)=&#39;15&#39;\n字符串不加引号  字符串类型字段使用时，不加引号，索引将失效  explain select * from tb_user where profession=&#39;软件工程&#39; and age=31 and status=0;\n模糊查询  如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效\nor连接的条件  用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到\n数据分布影响  如果MySQL评估使用索引比全表更慢，则不使用索引\nSQL提示  SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的\nuse index  explain select * from tb_user use index(idx_user_pro) where profession = &#x27;软件工程&#x27;;\n\n只是建议，MySQL有可能不接受\n\n\nignore index   explain select * from tb_user ignore index(idx_user_pro) where profession = &#x27;软件工程&#x27;;\nforce index   explain select * from tb_user force index(idx_user_pro) where profession = &#x27;软件工程&#x27;;\n\n\n覆盖索引（不需要回表查询）  尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到），减少select *  explain select id,profession,age,status from tb_user where profession = &#x27;软件工程&#x27; and age=31 and status=&#x27;0&#x27;;\n  ——using where;using index  explain select id,profession,age,status，name from tb_user where profession = &#x27;软件工程&#x27; and age=31 and status=&#x27;0&#x27;;\n  ——using index condition\nusing index condition：查找使用了索引，但是需要回表查询数据using where;using index：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据\n\n\n前缀索引  当字段类型为字符串（varchar，text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率\n语法：  create index idx_xxxx on table_name(column(n));\n前缀长度  可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的  select count(distinct email)/count(*) from tb_user;select count(distinct substring(email,1,5))/count(*) from tb_user;\n\n\n单列&amp;联合索引  单列索引：即一个索引只包含单个列  联合索引：即一个索引包含了多个列  在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引    多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询\n创建索引时得考虑索引的先后顺序\n\n\n\n索引设计原则\n针对于数据量较大，且查询比较频繁的表建立索引\n针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引\n尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高\n如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引\n尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率\n要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率\n如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询\n\n","categories":["Java"],"tags":["mysql"]},{"title":"JavaSE","url":"/2025/10/26/java/","content":" Javaday1一、安装Java Development Kit（JDK）\njavac和java\n\n\njava:执行工具\njavac：编译工具\n\n\njdk的组成\nJVM（Java Virtual Machine）：Java虚拟机，真正运行Java程序的地方\n核心类库（API）：Java自己写好的程序，给程序员自己的程序调用的\n\n\n\n\nJVM和核心类库构成JRE（Java Runtime Environment）：Java的运行环境\nJRE和开发工具构成JDK（Java Development Kit）：Java开发工具包（包括上面所有）\n\n二、配置环境变量\nPath环境变量可用于配置程序的所在路径，以方便在命令行窗口的任意目录下直接通过命令启动该程序（目的：可以在任何位置上运行Java命令）1.注意事项\n目前较新的JDK在安装时，会自动配置javac、java程序的路径到Path环境变量中\n较老版本的JDK不会自动配置，需要手动配置\n建议为JDK再配置JAVA_HOME环境变量\n\n\n建议为JDK再配置JAVA_HOME环境变量\n\n\nJAVA_HOME： 是用于告诉操作系统JDK安装在了哪个位置（将来其他技术要通过这个环境变量找JDK）\n配置后建议把Path中改为%JAVA_HOME%\\bin，这样更新时只用更改一处\n\n三、选择开发工具文本编辑器&#x2F;集成开发环境（IDE）\n四、创建第一个Java程序使用文本编辑器+命令行\n\n编写代码：使用文本编辑器创建“HelloWorld.java”文本文件public class HelloWorld&#123;\tpublic static void main(String[] args)&#123;\t\tSystem.out.println(&quot;Hello,World!&quot;);\t&#125;&#125;\n编译代码:打开命令行窗口，切换到.java文件所在目录，然后输入javac HelloWorld.java来编译代码，如果一切正常，这将会生成一个HelloWorld.class文件\n运行程序：在同一命令行窗口，输入java HelloWorld来运行程序，输出&quot;Hello,World!&quot;\n\n四、使用IDEA开发第一个Java程序的步骤\n创建工程 new Project建议先不要建java工程，建Empty Project\n创建模块 new Module\n创建包 new Package包一定要建在模块下包名：公司域名的倒写例：www.itheima.com-&gt;com.itheima.技术名称(全部用英文小写)\n创建类（类名不要带后缀）编译后的class文件在工程路径下的一个out文件夹里\n\n五、快捷键\n\n\n快捷键\n作用\n\n\n\nmain&#x2F;psvm、sout\n快速键入相关代码\n\n\nCtrl+D\n复制当前行数据到下一行\n\n\nCtrl+Y\n删除所在行，建议用Ctrl+X\n\n\nCtrl+Alt+L\n格式化代码\n\n\nALT+SHIFT+上，ALT+SHIFT+下\n上下移动当前代码\n\n\nCtrl+&#x2F;，Ctrl+Shift+&#x2F;\n对代码进行注释\n\n\n六、IDEA中的其他操作\n导入模块File-&gt;New-&gt;Module from Existing Sources\n删除模块先remove再delete\n\n七、Java的基本语法\nJava开发的软件，功能的最小单位是一个一个的方法\n注释注释方法与c++相同文档注释（通常用在类和方法上方）：/**    注释内容    注释内容*/\n数据类型字符串类型：String（大写）基本数据类型转换成String类型：...+ &quot;&quot;布尔值类型：boolean（默认为false）\n类型转换表达式类型转换：\n\n\n表达式的最终结果类型由表达式中的最高类型决定\n在表达式中，byte、short、char是直接转换成int类型参与运算的\n\nday2一、输入输出步骤：\n\n导包：告诉程序去JDK的哪个包中找扫描器技术import java.util.Scanner\n创建键盘扫描器对象Scanner sc=new Scanner(System.in)\n等待接收用户输入数据String name=sc.nextLine();int age=sc.nextInt();\n\n\n注意：System、String在JDK中的Java.lang包下\nlang包不需要我们导包，是默认的包\n\n二、扩展赋值运算符+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;\n\n注意：扩展的赋值运算符隐含了强制类型转换  byte a1=10;byte a2=20;a1=(byte)(a1+a2);//正常写需要强制类型转换（byte、short、char在参与算数运算时会首先自动提升为int类型）a1+=a2;//隐含强制类型转换\n\nday3数组\n静态初始化数组  String[] names=&#123;&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;&#125;\n  完整定义形式：  String[] names=new String[]&#123;&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;&#125;\n  也可写作  String names[]=new String[]&#123;&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;&#125;\n随机获取一个索引值Math.random()：0到1之间的小数（左闭右开）names.length：元素个数（与c++区别：没有括号）int index=(int)(Math.random()*names.length);\nString name=names[index];\n动态初始化数组  double[] scores=new double[8];//scores=[0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]（有默认值）\n  double[] scores=new double[8];Scanner sc=new Scanner(System.in);for(int i=0;i&lt;scores.length;i++)&#123;    System.out.println(&quot;请输入第&quot;+(i+1)+&quot;个学生的成绩：&quot;);    scores[i]=sc.nextDouble();&#125;\n二维数组  String[][] matrix=&#123;&#123;&quot;1&quot;,&quot;2&quot;,&quot;3&quot;&#125;,&#123;&quot;4&quot;,&quot;5&quot;,&quot;6&quot;&#125;,&#123;&quot;7&quot;,&quot;8&quot;,&quot;9&quot;&#125;&#125;;String[][] matrix=new String[][]&#123;&#123;&quot;1&quot;,&quot;2&quot;,&quot;3&quot;&#125;,&#123;&quot;4&quot;,&quot;5&quot;,&quot;6&quot;&#125;,&#123;&quot;7&quot;,&quot;8&quot;,&quot;9&quot;&#125;&#125;;\n  int[][] arr=new int[3][5];\n  //打印行列信息for(int i=0;i&lt;3;i++)&#123;    String[] names=matrix[i];    for(int j=0;j&lt;3;j++)&#123;        System.out.print(names[j]+&quot;\\t&quot;);    &#125;    System.out.println();&#125;\n\nday4面向对象编程\n类定义  public class Star&#123;    String name;    int age;    double height;    double weight;&#125;\n在计算机中的运行\n\n基础语法\n构造器类比与c++的构造函数\nthis  this主要用来解决变量名称冲突问题  public Student(String name,int age,char sex)&#123;    this.name=name;    this.age=age;    this.sex=sex;&#125;\n封装  java风格的私有成员声明  public class Student&#123;    String name;    private int age;    private double chinese;    private double math;&#125;\njavabeanjavabean是一种特殊类（实体类）要求\n\n\n类中的成员变量全部私有，并提供public修饰的getter&#x2F;setter方法\n类中需要提供一个无参数构造器，有参数构造器可选实体类的基本作用：创建它的对象，存取数据（封装数据）实体类应用场景：\n\n\nstatic\n  可用类名（推荐）&#x2F;对象访问静态变量  - 在计算机中的运行    扫描发现存在静态变量后复制一份到堆内存  静态变量的应用场景  \n    搞懂main方法  \n  静态方法的常见应用场景：做工具类\n\n工具类没有创建对象的需求，建议将工具类的构造器进行私有（不能创建对象）  \n\n  静态方法、实例方法访问注意事项  \n\n\n继承\n语法  public class B extends A&#123;&#125;\n权限修饰符若没有权限修饰符默认为public（与c++区别）\n继承的特点\ntips：如果多个类写在一个类中，只能有一个类前面用public修饰\n\n\n\n就近原则\n\n方法重写其实就是就近原则，要求：方法名称、形参列表必须一样标准写法：在重写方法前写@override（更安全，可读性更好）方法重写的其它注意事项\n子类重写父类方法时，访问权限必须大于或者等于父类该方法的权限（public&gt;protected&gt;缺省）\n重写的方法返回值类型，必须与被重写方法的返回值类型一样，或者范围更小\n私有方法、静态方法不能被重写，如果重写会报错的\n\n\n\n方法重写在开发中的常见应用场景重写toString方法\n\n子类构造器的特点子类的全部构造器都会先调用父类的构造器（无参或有参都行），再执行自己的构造器子类构造器是如何实现调用父类构造器的\n默认情况下，子类全部构造器的第一行代码都是super()（写不写都有），它会调用父类的无参数构造器\n如果父类没有无参数构造器，则我们必须在子类构造器的第一行手写super(…)，指定去调用父类的有参数构造器\n\n\n\n子类构造器调用父类构造器的应用场景super(name,sex)（与c++的初始化列表比较）\n\n构造器用this()调用兄弟构造器（类比于c++的委托构造）\n\n多态方法：编译看左边，运行看右边成员变量：编译看左边，运行也看左边原因：多态强调的是对象多态、行为多态，并没有强调成员变量多态\n\n多态的好处和存在的问题好处：1. 在多态形式下，右边对象是解耦合的（像组件一样可随时更换），更便于扩展和维护2. 定义方法时，使用父类类型的形参，可以接收一切子类对象，扩展性更强、更便利问题：多态下不能使用子类的独有功能\n\n多态下的类型转换问题强制类型转换：子类 变量名&#x3D;（子类）父类变量注意事项：\n\n存在继承&#x2F;实现关系就可以在编译阶段进行强制类型转换，编译阶段不会报错\n运行时，如果发现对象的真实类型与强转后的类型不同，就会报类型转换异常（ClassCastException）的错误出来\n\n  强转前，Java建议：  使用instanceof关键字，判断当前对象的真实类型，再进行强转  p instanceof Student\n\n\nday5final关键字-详解-java常量\n修饰类：该类被称为最终类，特点是不能被继承了（一般用于修饰工具类）\n\n修饰方法：该方法被称为最终方法，特点是不能被重写了\n\n修饰变量：该变量有且仅能被赋值一次\n\n成员变量\n静态成员变量（修饰后成为常量，通常用这个值作为系统的配置信息，类比于c++的const）\n实例成员变量（final修饰实例变量一般没有意义）\n\n\n局部变量\n\n\nfinal修饰基本类型的变量，变量存储的数据不能被改变\nfinal修饰引用类型的变量，变量存储的地址不能被改变，但地址所指向对象的内容是可以被改变的\n程序编译后，常量会被“宏替换”：出现常量的地方全部会被替换成其记住的字面量，这样可以保证使用常量和直接用字面量的性能是一样的  \n\n\n\n单例设计模式-懒汉式单例-饿汉式单例设计模式：具体问题的最优解决方案单例设计模式作用：确保某个类只能创建一个对象\n\n饿汉式单例：  public class A&#123;    //2、定义一个静态变量，用于基本本类的一个唯一对象    //public static final A a=new A();    private static A a=new A();//防止类外改成null，造成对象丢失    //1、私有化构造器：确保单例类对外不能创建太多对象，单例才有可能性    private A()&#123;    &#125;    //3、提供一个公开的静态方法，返回这个类的唯一对象    public static A getInstance()&#123;        return a;    &#125;&#125;\n懒汉式单例类用对象前，才开始创建对象  public class B&#123;    //2、私有化静态变量    private static B b;    //1、私有化构造器    private B()&#123;    &#125;    //3、提供静态方法返回对象：真正需要对象的时候才开始创建对象    public static B getInstance()&#123;        if(b==null)&#123;            //第一次拿对象时，会创建对象，给静态变量b记住            b=new B();        &#125;        return b;    &#125;&#125;\n\n枚举枚举类的写法\n修饰符 enum 枚举类名&#123;    名称1，名称2，...;    其他成员...&#125;\npublic enum A&#123;    X,Y,Z;    ...&#125;\n特点：\n\n枚举类中的第一行，只能写枚举类的对象名称，且要用逗号隔开\n这些名称，本质是常量，每个常量都记住了枚举类的一个对象\n\n\n枚举类的特点java.lang.Enum类重写了toString方法使得输出枚举对象时输出的是名称而不是地址\n\n拿枚举对象索引的方法：调用ordinal方法\n\n枚举类的常见应用场景枚举类很适合做信息分类和标志\n\n抽象类\n\n抽象类的注意事项、特点\n抽象类中不一定要有抽象方法，有抽象方法的类必须是抽象类\n类有的成员：成员变量、方法、构造器，抽象类都可以有\n抽象类最主要的特点：抽象类不能创建对象，仅作为一种特殊的父类，让子类继承并实现\n一个类继承抽象类，必须重写完抽象类的全部抽象方法，否则这个类也必须定义成抽象类\n\n\n使用抽象类的好处父类知道每个子类都要做某个行为，但每个子类要做的情况不一样，父亲就定义成抽象方法，交给子类去重写实现，我们设计这样的抽象类，就是为了更好的支持多态类比c++的virtual，这样父类就不用多定义方法的内容\n模板方法设计模式写法\n定义一个抽象类\n在里面定义2个方法\n一个是模板方法：把共同的实现步骤放里面去\n一个是抽象方法：不确定的实现步骤，交给具体的子类来完成\n\n\n\n\n\n建议使用final关键字修饰模板方法，为什么？\n\n模板方法是给子类直接使用的，不能被子类重写\n一旦子类重写了模板方法，模板方法就失效了\n\n接口关键字：interfaceJDK 8之前，接口中只能定义常量和抽象方法\n\n常量：接口中定义常量可以省略public static final不写，默认会加上去\n抽象方法：接口中定义抽象方法可以省略public abstract不写，默认会加上去\n\n\n注意：接口不能创建对象\n接口是用来被类实现（implements）的，实现接口的类称为实现类，一个类可以同时实现多个接口修饰符 class 实现类类名 implements 接口1，接口2，接口3，...&#123;    //实现类实现多个接口，必须重写完全部接口的全部抽象方法，否则实现类需要定义成抽象类&#125;\n接口的好处\n弥补了类单继承的不足，一个类同时可以实现多个接口，使类的角色更多，功能更强大\n让程序可以面向接口编程，这样程序员就可以灵活方便的切换各种业务实现（更利于程序的解耦合）\n\n\nJDK8新增的三个方法，几点注意事项第三点：一般的静态方法可以通过子类类名调用，但接口的静态方法只能用当前接口名来调用新增方法作用：增强了接口的能力，更便于项目的扩展和维护（如果接口中新增了一个方法，通过用default可以不用在每个实现类中都新增方法）\n接口的注意事项\n接口与接口可以多继承，一个接口可以同时继承多个接口【重点】\n一个接口继承多个接口，如果多个接口中存在方法签名冲突（一样不算冲突），则此时不支持多继承，也不支持多实现\n一个类继承了父类，又同时实现了接口，如果父类中和接口中有同名的默认方法，实现类会优先用父类的一定要调用接口方法：用一个方法中转A2.super.show()\n\n\n\n\n一个类实现了多个接口，如果多个接口中存在同名的默认方法，可以不冲突，这个类重写该方法即可\n\n\n抽象类和接口的区别相同点：\n\n都是抽象形式，都可以有抽象方法，都不能创建对象\n都是派生子类形式：抽象类是被子类继承使用，接口是被实现类实现\n一个类继承抽象类，或者实现接口，都必须重写完他们的抽象方法，否则自己要成为抽象类或者报错\n都能支持多态，都能实现解耦合\n\n  不同点：  5. 抽象类中可以定义类的全部普通成员，接口只能定义常量、抽象方法（JDK8新增的三种方式）  6. 抽象类只能被类单继承，接口可以被类多实现（一个类继承抽象类就不能再继承其他类，一个类实现了接口还可以继承其他类或者实现其他接口）  7. 抽象类体现模板思想，更利于做父类，实现代码的复用性  8. 接口更适合做功能的解耦合，解耦合性更强更灵活\n\n\nlombok技术lombok技术可以实现为类自动添加getter setter方法、无参数构造器、toString方法等方法：\n\n类前写上@Data\n光标移到上面，按alt+enter\nAdd’lombok’to classpath（别的公司写的框架，需要联网）\n\n默认提供无参构造器若要提供有参构造器，需加@AllArgsConstructor但是有参构造器写了无参构造器就没了因此需再写上@NoArgsConstructor@Data能够重写toString方法，输出对象时输出对象全部信息\n\n注意：要打开启用注解处理，否则报错\n\nday6类中的成分-代码块代码块是类的5大成分之一（成员变量、构造器、方法、代码块、内部类）代码块分为两种\n\n静态代码块\n格式：static{}\n特点：类加载时自动执行（与类一起优先加载），由于类只会加载一次，所以静态代码块也只会执行一次\n作用：完成类的初始化，例如：对静态变量的初始化赋值\n\n\n实例代码块\n格式：{}\n特点：每次创建对象时，执行实例代码块，并在构造器前执行\n作用：和构造器一样，都是用来完成对象的初始化的，例如：对实例变量进行初始化赋值\n\n\n\n类中的成分-内部类\n\n成员内部类\n\n静态内部类静态内部类中可以直接访问外部类中的静态成员，不可以直接访问外部类的实例成员原因：实例成员是属于外部类的对象的，而静态内部类不属于外部类的对象（成员内部类属于外部类的对象）定义成员内部类还是静态外部类？都可以\n\n局部内部类（了解）\n\n匿名内部类（最重要）是一种特殊的局部内部类所谓匿名：指的是程序员不需要为这个类声明名字，默认有个隐藏的名字\n\n特点：匿名内部类本质就是一个子类，并会立即创建出一个子类对象\n作用：用于更方便的创建一个子类对象\n\n  new 类或接口（参数值...）&#123;    类体（一般是方法重写）;&#125;;\n  new Animal()&#123;    @Override    public void cry()&#123;    &#125;&#125;;\n\n    \n\n  匿名内部类在开发中的常见形式  通常作为一个对象参数传输给方法    对象回调思想\n\n  匿名内部类在开发中的真实使用场景实例  一、    二、  //需求：按照年龄升序排序。可以调用sun公司写好的API直接对数组进行排序//public static void sort(T[] a,Comparator&lt;T&gt; c)//      参数一：需要排序的数组//      参数二：需要给sort声明一个Comparator比较器对象（指定排序的规则）//  sort方法内部会调用匿名内部类对象的compare方法，对数组中的学生对象进行两两比较，从而实现排序Arrays.sort(students,new Comparator&lt;Student&gt;()&#123;    @Override    public int compare(Student o1,Student o2)&#123;        //指定排序规则：        //如果你认为左边对象  大于  右边对象  那么返回正整数        //如果你认为左边对象  小于  右边对象  那么返回负整数        //如果两边相等那么返回0        if(o1.getAge()&gt;o2.getAge())&#123;            return 1;        &#125;else if(o1.getAge()&lt;o2.getAge())&#123;            return -1;        &#125;        return 0;        return o1.getAge()-o2.getAge();//按照年龄升序        return o2.getAge()-o1.getAge();//按照年龄降序    &#125;&#125;);\n\n\nday7函数式编程Lambda此“函数”类似于数学中的函数（强调做什么），只要输入的数据一致返回的结果也是一&#x3D;一致的Java中的函数（Lambda表达式）：(x)-&gt;2x+1函数式编程解决了什么问题？使用lambda函数替代某些匿名内部类对象，从而让程序代码更简洁，可读性更好\n\nLambda表达式JDK 8开始新增的一种语法形式，它表示函数可以用于替代某些匿名内部类对象，从而让程序更简洁，可读性更好\n注意：lambda表达式只能替代函数式接口的匿名内部类\n\n  什么是函数式接口  有且仅有一个抽象方法的接口  @FunctionalInterface//声明函数式接口的注解，约束当前接口必须是函数式接口（可加可不加）  Lambda表达式示例  public class LambdaDemo &#123;public static void main(String[] args) &#123;    Swim s1=() -&gt; &#123;        System.out.println(&quot;学生游泳很快&quot;);        &#125;;    s1.swimming();    &#125;&#125;//函数式接口：只有一个抽象方法的接口@FunctionalInterface//声明函数式接口的注解interface Swim&#123;    void swimming();&#125;\n  Lambda表达式原理：可根据上下文推断出原本应为的匿名内部类\nLambda的省略规则作用：用于进一步简化Lambda表达式的写法具体规则\n参数类型可以全部省略不写\n如果只有一个参数，参数类型省略的同时”()”也可以省略，但多个参数不能省略”()”\n如果Lambda表达式中只有一行代码，大括号可以不写，同时要省略分号”;”。如果这行代码是return语句，也必须去掉return\n\n\n\n方法引用\n静态方法引用类名::静态方法使用场景如果某个Lambda表达式里只是调用一个静态方法，并且”-&gt;”前后参数的形式一致，就可以使用静态方法引用\n实例方法引用对象名::实例方法使用场景如果某个Lambda表达式里只是通过对象名称调用一个实例方法，并且”-&gt;”前后参数的形式一致，就可以使用实例方法引用\nDouble.compare()能够比较double类型大小，返回-1、0、1\n\n\n特定类型的方法引用特定类的名称::方法使用场景如果某个Lambda表达式里只是调用一个特定类型的实例方法，并且前面参数列表中的第一个参数是作为方法的主调，后面的所有参数都是作为该实例方法的入参的，则此时就可以使用特定类型的方法引用\n构造器引用类名::new使用场景如果某个Lambda表达式里只是在创建对象，并且”-&gt;”前后参数情况一致，就可以使用构造器引用\n\n常用API\nStringString创建字符串对象的方式String创建对象的区别\n\n只要是以”…”方式写出的字符串对象，会存储到字符串常量池，且相同内容的字符串只存储一份\n通过new方式创建字符串对象，每new一次都会产生一个新的对象放在堆内存中\n\n      String提供的常用方法    equals最重要，不能直接“&#x3D;&#x3D;”，因为比较的是地址  案例：用String开发验证码  \n\nArrayList集合是一种容器，用来装数据的，类似于数组（ArrayList类似于c++的vector）实例\n\n\nday8GUI界面编程GUI，全称Graphical User Interface,是指图形用户界面\n\nJava的GUI编程包\n\nAWT(Abstract Window Toolkit)  提供了一组原生的GUI组件，依赖于操作系统的本地窗口系统\nSwing  基于AWT，提供了更丰富的GUI组件，轻量级组件，不依赖于本地窗口系统\n\n\n常用的Swing组件\n\nJFrame：窗口\nJPanel：用于组织其他组件的容器\nJButton：按钮组件\nJTextField：输入框\nJTable：表格\n\n\n常见的布局管理器（了解）（Layout Manager）决定组件在容器中的布局方式，避免了手动设置每个组件的位置和大小，从而简化了GUI设计过程\n\nFlowLayout  \nBorderLayout  \nGridLayout  \nBoxLayout  \n\n\n常用的事件监听器对象\n\n点击事件监听器  \n按键事件监听器    窗口上盖了一层面板，面板上又有按钮，因此按钮是焦点，要控制窗口就要让窗口再次成为焦点，但点击按钮后按钮又重新成为焦点\n\n\n事件的几种常见写法\n\n\n\n直接提供实现类，用于创建事件监听对象\n直接使用匿名内部类的对象，代表事件监听对象\n自定义窗口，让窗口对象实现事件接口自定义窗口（高级）\n\nday9项目实战一般会创建一个app类来运行shift+f6可以同步更改变量名\n异常\nJava的异常体系\n异常的作用\n自定义异常Sun公司已经在摒弃编译时异常了，最好定义运行时异常\n\n泛型定义类、接口、方法时，同时声明了一个或者多个类型变量（如：）称为泛型类、泛型接口、泛型方法，它们统称为泛型\npublic class ArrayList&lt;E&gt;&#123;&#125;\n作用：泛型提供了在编译阶段约束所能操作的数据类型，并自动进行检查的能力！这样可以避免强制类型转换，及其可能出现的异常泛型的本质：把具体的数据类型作为参数传给类型变量\n\n泛型类\n  修饰符 class 类名&lt;类型变量，类型变量，...&gt;&#123;&#125;\n  public class ArrayList&lt;E&gt;&#123;...   &#125;\n注意：类型变量建议用大写的英文字母，常用的有：E(Element)、T(Type)、K(Key)、V(Value)等\n\n泛型接口\n  修饰符 interface 接口名&lt;类型变量，类型变量，...&gt;&#123;&#125;\n  public interface A&lt;E&gt;&#123;    ...&#125;\n注意：类型变量建议用大写的英文字母，常用的有：E(Element)、T(Type)、K(Key)、V(Value)等\n\n泛型方法-通配符-上下限\n\n泛型方法  修饰符&lt;类型变量，类型变量，...&gt;返回值类型 方法名（形参列表）&#123;&#125;\n  public static &lt;T&gt; void test(T t)&#123;&#125;\n通配符  就是“?”，可以在“使用泛型”的时候代表一切类型；E T K V是在定义泛型的时候使用\n泛型的上下限\n泛型上限：？ extends Car：？能接收的必须是Car或者其子类\n泛型下限：？ super Car：？能接收的必须是Car或者其父类\n\n\n\n    有了上下限之后狗就进不来了\n\n泛型支持的类型-包装类\n\n泛型支持的类型  泛型不支持基本数据类型，只能支持对象类型（引用数据类型）    泛型擦除：泛型工作在编译阶段，等编译后泛型就没用了，所以泛型在编译后都会被擦除。所有类型会恢复成Object类型\n包装类  包装类就是把基本类型的数据包装成对象的类型    用第二个原因：valueOf方法提前缓存了一个数组来存[-128,127]的整数，在此范围内都是同一个对象    自动装箱：基本数据类型可以自动转换为包装类型  自动拆箱：包装类型可以自动转换为基本数据类型    包装类具备的其他功能    \n\n\n\nday10\nCollection集合\n\nCollection的常用功能\n\nCollection的遍历\n\n迭代器遍历      next()是先取元素再移位，hasNext()是判断当前位置有没有元素  .iterator()实际上返回的是Iterator接口的实现类对象\n增强for循环 for(元素的数据类型 变量名 ： 数组或者集合)&#123;&#125;\n Collection&lt;Stirng&gt; c = new ArrayList&lt;&gt;();...for(String s : c)&#123;    System.out.println(s);&#125;\nLambda表达式  需要使用Collection的forEach方法来完成    简化：  \n\n\n三种遍历方式的区别认识并发修改异常问题\n\nfor循环解决直接删出现并发修改异常问题原因：删除后后一位顶替被删除元素，但是同时i++，导致删不完全\n\n解决方案1：删除数据后做一步i–操作  \n解决方案2：倒着遍历并删除（前提是支持索引）  \n\n\n迭代器解决方案：迭代器遍历并删除（使用迭代器自己的方法来删除）\n\n用增强for还有lambda都没有办法解决并发修改异常问题原因：Collection自带的next()方法会调用检查修改的方法，比对已修改值和期待修改值\n\n\n\n\nList集合\nList集合的特有方法\nArrayList和LinkedList的区别底层采用的数据结构不同，应用场景不同ArrayList底层是基于数组存储数据的（查询速度快、增删数据效率低）LinkedList底层是基于链表存储数据的（查询慢，链表增删相对快）\nArrayList  最开始数组容量为0，第一次扩容为10，第二次扩容为15（1.5倍）\nLinkedList  基于双链表实现的（对首尾元素进行增删改查的速度是极快的）——&gt;LinkedList新增了很多首尾操作的特有方法    可以用LinkedList来设计队列、栈\n\n\n\nSet集合Set要用到的常用方法，基本上就是Collection提供的。自己几乎没有额外新增一些常用功能\n\nHashSet当元素个数&#x3D;数组长度*0.75时对哈希表进行扩容两倍处理JDK8开始，当链表长度超过8，且数组长度&gt;&#x3D;64时，自动将链表转成红黑树，进一步提高了操作数据的性能\n\n自定义对象去重复    否则由于不同对象存储的位置不一样，系统不会认为这些对象是重复的  方法：右键，Generate，选中equals() and HashCode，重写这两个方法（equals()没有重写的话本质上是比较两个对象的内存地址）\n\n\nLinkedHashSet依然是基于哈希表实现的但是，它的每个元素都额外多了一个双链表的机制记录它前后元素的位置\n\nTreeSet底层是基于红黑树实现的排序注意：\n\n对于数值类型：Integer，Double，默认按照数值本身的大小进行升序排序\n对于字符串类型：默认按照首字符的编号升序排序\n对于自定义类型如Student对象，TreeSet默认是无法直接排序的\n\n\n自定义排序规则\n\n\nMap集合需要存储一一对应的数据时，就可以考虑使用Map集合来做- Map集合的体系特点- Map集合的常用方法- Map集合的遍历方式    1. 键找值        2. 键值对        3. Lambda表达式    案例\n\n\nMap集合的实现类\nHashMap集合的底层原理  实际上，原来学的Set系列集合的底层就是基于Map实现的，只是Set集合中的元素只要键数据，不要值数据而已  HashMap跟HashSet的底层原理是一模一样的，都是基于哈希表实现的\nLinkedHashMap的底层原理  底层数据结构依然是基于哈希表实现的，只是每个键值对元素又额外的多了一个双链表的机制记录元素顺序（保证有序）\nLinkedHashMap的底层原理  只能对键排序\n\n\n\nday11Stream流Stream流是jdk8开始新增的一套API（java.util.stream.*），可以用于操作集合或者数组的数据优势：Stream流大量的结合了Lambda的语法风格来编程，功能强大，性能高效，代码简洁，可读性好\n\nStream流的使用步骤\n\n获取Stream流      Stream.of()的参数可以为一个、多个、数组甚至没有\n常用中间方法  \n常用终结方法    \n收集Stream流      \nset.addAll(arrayList)可以把ArrayList变成Set\n\n\n\n  Collectors.toList()方法返回的是一个ArrayList，Stream流对象通过collect方法把数据传到ArrayList中  用了特殊类型的方法引用简化\n\n\n\n案例：做牌\n\n方法中可变参数就是一种特殊形参，定义在方法、构造器的形参列表里，格式是：数据类型…参数名称；可变参数的特点和好处特点：可以不传数据给它；可以传一个或者同时传多个数据给它；也可以传一个数组给它好处：常常用来灵活的接收数据\n\n注意事项：\n\n可变参数在方法内部就是一个数组\n可变参数在形参列表中只能有一个参列表的最后面\n可变参数在形参列表的最后面\n\n  \n\nCollections工具类\n\n\nday12File-IO流\nFileFile是java.io.包下的类，File类的对象，用于代表当前操作系统的文件（可以是文件、或文件夹）\nFile类只能对文件本身进行操作，不能读写文件里面存储的数据\n\n\nIO流用于读写数据的\n\nFile\n创建File类的对象\n\nFile封装的对象仅仅是一个路径名，这个路径可以是存在的，也允许是不存在的\n\n\nFlie提供的判断文件类型、获取文件信息功能\n\nFile提供的创建和删除文件的方法\n\nFile提供的遍历文件夹的方法\n\n注意：只能一级\n\n  \n\n\n字符集ASCII码使用一个字节存储一个字符，首位都是0（有效位为7位，可存储128个字符）\n\nGBK（汉字内码扩展规范，国标）汉字编码字符集，包含了2万多个汉字等字符，GBK中一个中文字符编码成两个字节的形式存储\n注意：GBK兼容ASCII字符集\n\n  GBK规定：汉字的第一个字节的第一位必须是1（确保能正确读取）\nUnicode字符集（统一码，也叫万国码）Unicode是国际组织制定的，可以容纳世界上所有文字、符号的字符集\nUTF-32  4个字节表示一个字符（占存储空间，通信效率变低）\nUTF-8字符集  是Unicode字符集的一种编码方案，采取可变长编码方案，共分四个长度区：1个字节，2个字节，3个字节，4个字节  英文字符、数字等只占1个字节（兼容标准ASCII编码），汉字字符占用3个字节  \n注意1：字符编码时使用的字符集，和解码时使用的字符集必须一致，否则会出现乱码注意2：英文，数字一般不会乱码，因为很多字符集都兼容了ASCII编码\n\n\n\n\n使用程序对字符进行编码和解码操作\n\nIO流\nIO流的分类InputStream、OutputStream、Reader、Writer（抽象类）FileInputStream、FileOutputStream、FileReader、FileWriter（实现类）\nFlieInputStream（文件字节输入流）作用：以内存为基准，可以把磁盘文件中的数据以字节的形式读入到内存中去\n一次性读取完全部字节    \n\n\nFileOutputStream（文件字节输出流）\\r\\n兼容性比\\n更好\n注意：IO流对象创建完后一定要关闭\n\n\n字节流做复制\n资源释放问题\n方案一首先fis和fis先定义成null，再在try里面new出来，finally里面加条件判断if ... !=null，然后再分别try-catch\n方案二（try-with-resource）\n\n\nFileReader（文件字符输入流）\nFileWriter（文件字符输出流）\n字符输出流写出数据后，必须刷新流，或者关闭流，写出去的数据才能生效 .flush()，刷新后，流可以继续使用（关闭包含了刷新）\n\n\n缓冲流\nBufferedInputStream缓冲字节输入流作用：可以提高字节输入流读取数据的性能\n缓冲字符输入流\n缓冲字符输出流\n性能分析（重点）\n\n\n\n\n其他流\n字符输入转换流（InputStreamReader）（继承Reader）  解决不同编码时，字符流读取文本内容乱码的问题  解决思路：先获取文件的原始字节流，再将其按真实的字符集编码转成字符输入流，这样字符输入流中的字符就不乱码了    \n打印流（PrintStream&#x2F;PrintWriter）作用：打印流可以实现更方便、更高效的打印数据出去，能实现打印啥出去就是啥出去\n特殊数据流\nDataOutputStream（数据输出流）允许把数据和其类型一并写出去\nDataInputStream（数据输入流）用于读取数据输出流写出去的数据\n\n\n\n\nCommons-io框架\n\nday13线程线程（Thread）是一个程序内部的一条执行流程程序中如果只有一条执行流程，那这个程序就是单线程的程序\n多线程多线程是指从软硬件上实现的多条执行流程的技术（多条线程由CPU负责调度执行）\n\n创建线程创建线程的注意事项：  1、启动线程必须是调用start方法，不是调用run方法\n\n直接调用run方法会当成普通方法执行，此时相当于还是单线程执行\n只有调用start方法才是启动一个新的线程执行\n\n  2、不要把主线程任务放在启动子线程之前\n\n多线程的创建方式一：继承Thread类\nmain方法本身是由一条主线程负责推荐执行的\n\n    方式一优缺点：  优点：编码简单  缺点：线程类已经继承Thread，无法继承其他类，不利于功能的扩展\n多线程的创建方式二：实现Runnable接口    方式二优缺点：  优点：任务类只是实现接口，可以继续继承其他类、实现其他接口，扩展性强  缺点：需要多一个Runnable对象    \n多线程的创建方式三：实现Callable接口  前两种线程创建方式都存在的一个问题：假如线程执行完毕后有一些数据需要返回，他们重写的run方法均不能直接返回结果  JDK5.0提供了Callable接口和FutureTask类来实现（多线程的第三种创建方式）  这种方式最大的优点：可以返回线程执行完毕后的结果    FutureTask本质是一个Runnable线程任务对象，可以交给Thread线程对象处理  获取数据时建议分开try-catch，可以互不影响    拿结果时，如果主线程发现本线程还没有执行完毕，会让出CPU，等本线程执行完毕后，才会往下执行\n\n\n线程的常用方法\n\n\n线程安全多个线程，同时操作同一个共享资源的时候，可能会出现业务安全问题\n线程同步线程同步是线程安全问题的解决方案核心思想：让多个线程先后依次访问共享资源，这样就可以避免出现线程安全问题线程同步的常见方案：加锁，每次只允许一个线程加锁，加锁后才能进入访问，访问完毕后自动解锁，然后其他线程才能再加锁进来\n\n方式一：同步代码块作用：把访问共享资源的核心代码给上锁，以此保证线程安全\n  synchronized(同步锁)&#123;    访问共享资源的核心代码&#125;\n  原理：每次只允许一个线程加锁后进入，执行完毕后自动解锁，其他线程才可以进来执行\n\n同步锁的注意事项  对于当前同时执行的线程来说，同步锁必须是同一把（同一个对象），否则会出bug\n\n锁对象的使用规范  建议使用共享资源作为锁对象，对于实例方法建议使用this作为锁对象  对于静态方法建议使用字节码（类名.class）对象作为锁对象  \n\n方式二：同步方法作用：把访问共享资源的核心方法给上锁，以此保证线程安全\n  修饰符 synchronized 返回值类型 方法名称（形参列表）&#123;    操作共享资源的代码&#125;\n  同步方法底层原理\n\n同步方法其实底层也是有隐式锁对象的，只是锁的范围是整个方法代码\n如果方法是实例方法：同步方法默认用this作为的锁对象\n如果方法是静态方法：同步方法默认用类名.class作为的锁对象\n\n\n同步代码块好还是同步方法好？\n\n范围上：同步代码块锁的范围更小（效率更高），同步方法锁的范围更大\n可读性：同步方法更好\n\n\n方式三：Lock锁最好将锁对象定义为final，保护锁对象unlock最好放在finally里，这样即使出现异常也能正常释放锁\n\n\n线程池线程池就是一个可以复用线程的技术\n\n不使用线程池的问题用户每发起一个请求，后台就需要创建一个新线程来处理，下次新任务来了肯定又要创建新线程处理的，创建新线程的开销是很大的，并且请求过多时，肯定会产生大量的线程出来，这样会严重影响系统的性能。\n线程池的工作原理\n创建线程池JDK5.0起提供了代表线程池的接口：ExecutorService如何创建线程池对象方式一：使用ExecutorService的实现类ThreadPoolExecutor自创建一个线程池对象方式二：使用Executors（线程池的工具类）调用方法返回不同特点的线程池对象\n方式一：使用ThreadPoolExecutor创建线程池ExecutorService的常用方法线程池的注意事项\n处理Runnable任务    任务队列有ArrayBlockingQueue和LinkedBlockingQueue\n处理Callable任务  \n\n\n方式二：通过Executors创建线程池Executors可能存在的陷阱\n\n\n并发&#x2F;并行进程正在运行的程序（软件）就是一个独立的进程线程是属于进程的，一个进程中可以同时运行很多个线程进程中的多个线程其实是并发和并行执行的并发的含义进程中的线程是由CPU负责调度执行的，但CPU能同时处理线程的数量优先，为了保证全部线程都能往前执行，CPU会轮询为系统的每个线程服务，由于CPU切换的速度很快，给我们的感觉这些线程在同时执行，这就是并发并行的含义在同一个时刻上，同时有多个线程在被CPU调度执行简单说说多线程是怎么执行的？并发和并行同时进行的\n\nday14网络编程可以让设备中的程序与网络上其他设备中的程序进行数据交互的技术（实现网络通信）\n\n基本的通信架构基本的通信架构有2种形式：CS架构（Client客户端&#x2F;Server服务端）、BS架构（Browser浏览器&#x2F;Server服务端）无论是CS架构，还是BS架构的软件都必须依赖网络编程Java提供了哪些网络编程解决方案？java.net.*包下提供了网络编程的解决方案\n\n网络编程三要素\n\nIPDNS域名解析第一次访问时本机的DNS域名解析器还不知道域名对应的IP地址，会先找运营商（安装宽带的）的DNS域名解析器找对应的IP地址公网IP、内网IPInetAddress代表IP地址\n端口用来标记正在计算机设备上运行的应用程序，被规定为一个16位的二进制，范围是065535端口分类周知端口：01023，被预先定义的知名应用占用（如：HTTP占用80，FTP占用21）注册端口：1024~49151，分配给用户进程或某些应用程序动态端口：49152到65535，之所以称为动态端口，是因为它一般不固定分配某种进程，而是动态分配注意：我们自己开发的程序一般选择使用注册端口，且一个设备中不能出现两个程序的端口号一样，否则报错\n协议网络上通信的设备，实现规定的连接规则，以及传输数据的规则被称为网络通信协议开放式网络互连标准：OSI网络参考模型传输层的2个通信协议\nUDP（User Datagram Protocol）：用户数据报协议  \nTCP（Transmission Control Protocol）：传输控制协议      传输数据会进行确认，以保证数据传输的可靠性    通信效率相对不高，可靠性更高，适用网页、文件下载、支付\n\n\nUDP通信的实现Java提供了一个java.net.DatagramSocket类来实现UDP通信多发多收：客户端和服务端都用while死循环，用户输入exit后退出循环\nTCP通信的实现Java提供了一个java.net.Socket类来实现TCP通信服务端是通过java.net包下的ServerSocket类来实现的客户端和服务端的字节输入输出流必须要对应多发多收：支持多个客户端消息：用多线程BS架构的原理线程对象其实也可以当成任务对象用\n\nday15项目实战-即时通讯前置知识\n时间相关的获取方案\nStringBuilder\nBigDecimalBigDecimal解决精度丢失问题\n\nday16Java高级技术单元测试就是针对最小的功能单元：方法，编写测试代码对其进行正确性测试\n\nJunit单元测试框架可以用来对方法进行测试，它是第三方公司开源出来的（很多开发工具已经集成了Junit框架，比如IDEA）优点：可以灵活的编写测试代码，可以针对某个方法执行测试，也支持一键完成对全部方法的自动化测试，且各自独立不需要程序员去分析测试的结果，会自动生成测试报告出来有时测试方法中还要做断言：断言结果是否与预期结果一致Assert.assertEquals()\n\n反射反射就是：加载类，并允许以编程的方式解剖类中的各种成分（成员变量、方法、构造器等）\n\n反射第一步：获得Class对象\n反射第二步：获取类中的成分并操作暴力访问私有构造器、方法、属性\n反射的作用\n基本作用：可以得到一个类的全部成分然后操作\n可以破坏封装性\n可以绕过泛型的约束（泛型编译成class文件后变成Object）最重要的用途是：适合做Java的框架，基本上，主流的框架都会基于反射设计出一些通用的功能\n\n\n\n注解注解就是Java代码里的特殊标记，比如：@Override，@Test等，作用是：让其他程序根据注解信息来决定怎么执行该程序\n\n注意：注解可以用在类上、构造器上、方法上、成员变量上、参数上等位置处\n\n\n自定义注解  public @interface 注解名称&#123;    public 属性类型 属性名() default 默认值；（public默认存在）&#125;\n  注意要加()  特殊属性名：value  如果注解中只有一个value属性，使用注解时，value名称可以不写  \n元注解指的是注解注解的注解  @Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.METHOD&#125;)public @interface Test&#123;&#125;\n\n注解的解析就是判断类上、方法上、成员变量上是否存在注解，并把注解里的内容给解析出来如何解析注解\n注解的应用场景\n\n动态代理代理实际上是典型的AOP（切面编程）思想\n","categories":["Java"],"tags":["JavaSE"]},{"title":"数据结构","url":"/2025/09/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","content":" 数据结构7.3.1 二叉排序树（BST）\n二叉排序树的查找\n//在二叉排序树中查找值位key的结点BSTNode *BST_Search(BSTree T,int key)&#123;    while(T!=nullptr&amp;&amp;key!=T-&gt;key)&#123;//若树空或等于根结点值，则结束循环        if(key&lt;T-&gt;key) T=T-&gt;child;//小于，则在左子树上查找        else T=T-&gt;rchild;//大于，则在右子树上查找    &#125;    return T;&#125;\n最坏空间复杂度O(1)\n//在二叉排序树中查找值为key的结点（递归实现）BSTNode *BSTSearch(BSTree T,int key)&#123;    if(T==nullptr)        return nullptr;//查找失败    if(key==T-&gt;key)        return T;//查找成功    else if(key&lt;T-&gt;key)        return BSTSearch(T-&gt;lchild,key);//在左子树中找    else        return BSTSearch(T-&gt;rchild,key);//在右子树中找&#125;\n最坏空间复杂度O(h)\n\n二叉排序树的插入\n//在二叉排序树插入关键字为k的新结点（递归实现）int BST_Insert(BStree &amp;T,int k)&#123;    if(T==nullptr)&#123;//原树为空，新插入的结点为根结点        T=(BSTree)malloc(sizeof(BSTNode));        T-&gt;key=k;        T-&gt;lchild=T-&gt;rchild=nullptr;        return 1;//返回1，插入成功    &#125;    else if(k==T-&gt;key)//树中存在相同关键字的结点，插入失败        return 0;    else if(k&lt;T-&gt;key)//插入到T的左子树        return BST_Insert(T-&gt;lchild,,k);    else//插入到T的右子树        return BST_Insert(T-&gt;rchild,k);&#125;\n注意函数参数是引用类型最坏空间复杂度O(h)\n\n二叉排序树的构造\n//按照str[]中的关键字序列建立二叉排序树void Creat_BST(BSTree &amp;T,int str[],int n)&#123;    T=nullptr;//初始时T为空树    int i=0;    while(i&lt;n)&#123;依次将每个关键字插入到二叉排序树中        BST_Insert(T,str[i]);        i++;    &#125;&#125;\n二叉排序树的删除先搜索找到目标结点：\n\n\n\n若被删除结点z是叶结点，则直接删除，不会破坏二叉排序树的性质\n若结点z只有一棵左子树或右子树，则让z的子树成为z父结点的子树，替代z的位置\n若结点z有左、右两棵子树，则令z的直接后继（或直接前驱）替代z，然后从二叉排序树中删去这个直接后继（或直接前驱），这样就转换成了第一或第二种情况原理：左子树结点值&lt;根结点值&lt;右子树结点值进行中序遍历，可以得到一个递增的有序序列z的后继：z的右子树中最左下结点（该结点一定没有左子树）z的前驱：z的左子树中最右下结点（该结点一定没有右子树）\n\n7.3.2_1 平衡二叉树（AVL）结点的平衡因子&#x3D;左子树高-右子树高（只可能是-1、0或1）\n//平衡二叉树结点typedef struct AVLNode&#123;    int key;//数据域    int balance;//平衡因子    struct AVLNode *lchild,*rchild;&#125;AVLNode,*AVLTree;\n\n平衡二叉树的插入每次调整的对象都是“最小不平衡子树”在插入操作中，只要将最小不平衡子树调整平衡，则其他祖先结点都会恢复平衡\n调整最小不平衡子树\nLL  \nRR  \n代码思路  \nLR    \nRL    \n\n\n\n恢复原因：插入操作导致“最小不平衡子树”高度+1，经过调整后高度恢复\n\n练习    \n\n查找效率分析1为根结点，令左子树结点数为$n_{h-1}$，右子树结点数为$n_{h-2}$，可得公式\n\n\n\n\n7.3.2_2_平衡二叉树的删除\n\n例子                \n\n7.3.3_1_红黑树的定义和性质平衡二叉树AVL：插入&#x2F;删除很容易破坏“平衡”特性，需要频繁调整树的形态。如：插入操作导致不平衡，则需要先计算平衡因子，找到最小不平衡子树（时间开销大），再进行LL&#x2F;RR&#x2F;LR&#x2F;RL调整红黑树RBT：插入&#x2F;删除很多时候不会破坏“红黑”特性，无需频繁调整树的形态。即便需要调整，一般都可以在常数级时间内完成平衡二叉树：适用于以查为主、很少插入&#x2F;删除的场景红黑树：适用于频繁插入、删除的场景，实用性更强\n\n红黑树的定义红黑树是二叉排序树-&gt;左&lt;根&lt;右与普通BST相比要求：\n每个结点或是红色的，或是黑色的\n根结点是黑色的\n叶结点（外部结点、NULL结点、失败结点）均是黑色的\n不存在两个相邻的红结点（即红结点的父结点和孩子结点均是黑色）\n对每个结点，从该结点到任一叶结点的简单路径上，所含黑结点的数目相同\n左根右，根叶黑，不红红，黑路同\n\nstruct RBnode&#123;    int key;//关键字的值    RBnode* parent;//父结点指针    RBnode* lChild;//左孩子指针    RBnode* rChild;//右孩子指针    int color;//结点颜色，如：可用0/1表示黑/红，也可使用枚举型enum表示颜色&#125;;\n\n\n补充概念：结点的黑高结点的黑高bh——从某结点出发（不含该结点）到达任一空叶结点的路径上黑结点总数\n红黑树的性质性质1：从根结点到叶结点的最长路径不大于最短路径的2倍（由4、5得）性质2：有n个内部结点的红黑树高度h&lt;&#x3D;2 $log_2(n+1)$性质2可证明红黑树**查找操作时间复杂度&#x3D;O($log_2(n)$)\n红黑树的查找与BST、AVL相同，从根出发，左小右大，若查找到一个空叶结点，则查找失败\n\n7.3.3_2_红黑树的插入- 与“黑高”相关的推论思考：根结点黑高为h的红黑树，内部结点数（关键字）至少有多少个回答：内部结点数最少的情况——总共h层黑结点的满树形态结论：若根结点黑高为h，内部结点数（关键字）最少有2^h-1个性质1证明：任何一条查找失败路径上黑结点数量都相同，而路径上不能连续出现两个红结点，即红结点只能穿插在各个黑结点中间性质2证明：若红黑树总高度&#x3D;h，则根结点黑高&gt;&#x3D;h&#x2F;2，因此内部结点数n&gt;&#x3D;$2^{h&#x2F;2}-1$，由此推出h&lt;&#x3D;2 $log_2(n+1)$\n7.3.3_3_红黑树的删除（难）重要考点：\n\n红黑树删除操作的时间复杂度&#x3D;O($log_2(n)$)\n在红黑树中删除结点的处理方式和“二叉排序树的删除”一样\n按2删除结点后，可能破坏“红黑树特性”，此时需要“调整结点颜色、位置”，使其再次满足“红黑树特性”\n\n7.4.1_1 B树\n五叉查找树//5叉排序树的结点定义struct Node&#123;    ElemType keys[4];//最多4个关键字    struct Node * child[5]；//最多5个孩子    int num;//结点中有几个关键字&#125;;\n如何保证查找效率若每个结点内关键字太少，导致树变高，要查更多层结点，效率低策略：m叉查找树中，规定除了根结点外，任何结点至少有[m&#x2F;2]（向上取整）个分叉，即至少含有[m&#x2F;2]-1（向上取整）个关键字eg：对于5叉排序树，规定除了根结点外，任何结点都至少有3个分叉，2个关键字策略：m叉查找树中，规定对于任何一个结点，其所有子树的高度都要相同\nB树\nB树的高度最小高度：最大高度思路一：最大高度思路二：\n\n7.4.1_2_B树的插入删除\nB树的插入新元素一定是插入到最底层“终端结点”，用“查找”来确定插入位置如果90插入到根结点，则各个失败结点不属于同一层\n\nB树的删除若被删除关键字在终端结点，则直接删除该关键字（要注意结点关键字个数是否低于下限[m&#x2F;2]-1）若被删除关键字在非终端结点，则用直接前驱或直接后继来替代被删除的关键字直接前驱：当前关键字左侧指针所指子树中“最右下”的元素直接后继：当前关键字右侧指针所指子树中“最左下”的元素\n\n对非终端结点关键字的删除，必然可以转化为对终端结点的删除操作向右兄弟借：\n\n\n\n向左兄弟借：兄弟不够借-&gt;合并：\n7.4.2_B+树- B+树的查找1. 多路查找2. 顺序查找- B+树 vs B树1. m阶B+树：结点中的n个关键字对应n棵子树m阶B树：结点中的n个关键字对应n+1棵子树2. m阶B树：根结点的关键字数$n\\in[1,m-1]$其他结点的关键字数$n\\in[[m&#x2F;2]-1,m-1]$m阶B+树：根结点的关键字数$n\\in[1,m]$其他结点的关键字数$n\\in[[m&#x2F;2],m]$3. m阶B+树：在B+树中，叶结点包含全部关键字，非叶结点中出现过的关键字也会出现在叶结点中m阶B树：在B树中，各结点中包含的关键字是不重复的4. m阶B+树：在B+树中，叶结点包含信息，所有非叶结点仅起索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址m阶B树：B树的结点中都包含了关键字对应的记录的存储地址\n7.5.1 散列表的基本概念\n散列表、散列函数散列表（哈希表，Hash Table）：是一种数据结构。特点是：可以根据数据元素的关键字计算出它在散列表的存储地址散列函数（哈希函数）：Addr&#x3D;H(key)建立了“关键字”-&gt;“存储地址”的映射关系理想情况下，在散列表中查找一个元素的时间复杂度为O(1)\n冲突、同义词冲突（碰撞）：在散列表中插入一个数据元素时，需要根据关键字的值确定其存储地址，若该地址已经存储了其他元素，则称这种情况为“冲突（碰撞）”同义词：若不同的关键字通过散列函数映射到同一个存储地址，则称它们为“同义词”\n如何减少冲突构造更适合的散列函数，让各个关键字尽可能地映射到不同的存储位置，从而减少“冲突”\n拉链法  \n开放定址法  \n\n\n\n7.2.5 散列函数的构造\n设计散列函数时应该注意什么\n除留余数法H(key)&#x3D;key%p散列表长为m，取一个不大于m但最接近或等于m的质数p适用场景：较为通用，只要关键字是整数即可\n\n\n拓展：为什么除留余数法要对质数取余原因：对质数取余，可以分布更均匀，从而减少冲突（取余运算会被“公因子”影响，参见《数论》）\n\n\n直接定址法H(key)&#x3D;key或H(key)&#x3D;a*key+b其中，a和b是常数。这种方法计算最简单，且不会产生冲突。若关键字分布不连续，空位较多，则会造成存储空间的浪费适用场景：关键字分布基本连续\n数字分析法\n平方取中法\n\n7.5.3_1 处理冲突的方法_拉链法拉链法（又称链接法、链地址法）：把所有“同义词”存储在一个链表中- 散列表的插入操作（拉链法解决冲突）考试时默认用头插法- 散列表的查找操作（拉链法解决冲突）在分析查找长度时，通常只统计“关键字的对比次数”，而链表“空指针的对比次数”不计入查找长度- 散列表的删除操作（拉链法解决冲突）Step1：根据散列函数计算目标元素的散列地址Step2：顺序查找散列地址对应的链表，若查找成功，将目标元素从链表中删除拓展：插入操作的小优化新元素插入链表时，若能保持链表有序，可以略微提高“查找”效率\n7.5.3_2 处理冲突的方法_开放定址法开放定址法：如果发生“冲突”，就给新元素找另一个空闲位置为什么叫“开放定址”——一个散列地址，既对同义词开放，也对非同义词开放\n\n开放定址法的基本原理\n线性探测法（插入、查找操作）\n平方探测法（插入、查找操作）\n双散列法（插入、查找操作）\n伪随机序列法（插入、查找操作）\n如何删除一个元素\n关于删除操作带来的问题：查找效率低下，散列表看起来很满，实则很空Tips：可以不定期整理散列表内的数据\n注：新元素也可以插入到已被“逻辑删除”的地址\n\n\n\n\n拓展：“探测覆盖率”\n\n线性探测法\n平方探测法\n双散列法\n若表长本身就是质数，一定跟任何一个小于它的数（1除外）互质\n伪随机序列法的“探测覆盖率”\n\n7.5.4 散列查找的性能分析（以线性探测法为例）易错点：采用开放定址法时，删除一个元素是逻辑删除，而非物理删除！这一点将影响查找长度的计算\n\n装填因子\n聚集（堆积）现象在处理冲突的过程中，几个初始散列地址不同的元素争夺同一个后继散列地址的现象称作“聚集”（或称作“堆积”）线性探测法在发生冲突时，总是往后探测相邻的后一个单元，很容易造成同义词、非同义词的“聚集（堆积）”现象，从而影响查找效率，导致ASL提升\n使用“平方探测法”减少聚集现象\n\n8.1_排序的基本概念\n排序算法的评价指标时间复杂度+空间复杂度、稳定性稳定的排序算法一定比不稳定的好？不一定，看实际需求\n排序算法的分类\n内部排序  数据都在内存中（关注如何使算法时、空复杂度更低）\n外部排序  数据太多，无法全部放入内存（还要关注如何使读&#x2F;写磁盘次数更少）\n\n\n\n8.2.1+8.2.2_插入排序\n算法实现//直接插入排序void InsertSort(int A[],int n)&#123;    int i,j,temp;    for(i=1;i&lt;n;i++)//将各元素插入已排好序的序列中        if(A[i]&lt;A[i-1])&#123;//若A[i]关键字小于前驱            temp=A[i];//temp暂存A[i]            for(j=i-1;j&gt;=0&amp;&amp;A[j]&gt;temp;--j)//检查所有前面已排好序的元素                A[j+1]=A[j];//所有大于temp的元素都向后挪位            A[j+1]=temp;//复制到插入位置        &#125;&#125;\n带哨兵//直接插入排序（带哨兵）void InsertSort(int A[],int n)&#123;    int i,j;    for(i=2;i&lt;=n;i++)//依次将A[2]~A[n]插入到前面已排序序列        if(A[i]&lt;A[i-1])&#123;//若A[i]关键码小于其前驱，将A[i]插入有序表            A[0]=A[i];//复制为哨兵，A[0]不存放元素            for(j=i-1;A[0]&lt;A[j];--j)//从后往前查找待插入位置                A[j+1]=A[j];//向后挪位            A[j+1]=A[0];//复制到插入位置        &#125;&#125;\n空间复杂度：O(1)时间复杂度：主要来自对比关键字、移动元素若有n个元素，则需要n-1趟处理最好情况：原本就有序,O(n)最坏情况：原本为逆序,O(n²)平均时间复杂度：O(n²)算法稳定性：稳定\n优化——折半插入排序当low&gt;high时折半查找停止，应将[low,i-1]内的元素全部右移，并将A[0]复制到low所指位置//折半插入排序void InsertSort(int A[],int n)&#123;    int i,j,low,high,mid;    for(i=2;i&lt;=n;i++)&#123;//依次将A[2]~A[n]插入前面的已排序序列        A[0]=A[i];//将A[i]暂存到A[0]        low=1;high=i-1;//设置折半查找的范围        while(low&lt;=high)&#123;            mid=(low+high)/2;//取中间点            if(A[mid]&gt;A[0]) high=mid-1;//查找左半子表            else low=mid+1;//查找右半子表        &#125;        for(j=i-1;j&gt;=high+1;--j)            A[j+1]=A[j];//统一右移元素，空出插入位置        A[high+1]=A[0]//插入操作    &#125;&#125;\n时间复杂度依然是O(n²)\n对链表进行插入排序\n\n8.2.3_希尔排序希尔排序：先追求表中元素部分有序，再逐渐逼近全局有序希尔本人建议：每次将增量缩小一半\n\n算法实现//希尔排序void ShellSort(int A[],int n)&#123;    int d,i,j;    //A[0]只是暂存单元，不是哨兵，当j&lt;=0时，插入位置已到    for(d=n/2;d&gt;=1;d=d/2)//步长变化        for(i=d+1;i&lt;=n;++i)            if(A[i]&lt;A[i-d])&#123;需将A[i]插入有序增量子表                A[0]=A[i];//暂存在A[0]                for(j=i-d;j&gt;0&amp;&amp;A[0]&lt;A[j];j-=d)                    A[j+d]=A[j];//记录后移，查找插入的位置                A[j+d]=A[0];//插入            &#125;&#125;\n此写法的++i说明不是一个子序列排完再排另一个子序列，而是逐步排完\n算法性能分析空间复杂度：O(1)时间复杂度：和增量序列$d_1$,$d_2$,$d_3$…的选择有关，目前无法用数学手段证明确切的时间复杂度最坏时间复杂度为O(n²)，当n在某个范围内时，可达O(n¹·³)\n\n8.3.1_冒泡排序\n算法实现//冒泡排序void BubbleSort(int A[],int n)&#123;    for(int i=0;i&lt;n-1;i++)&#123;        bool flag=false;//表示本趟冒泡是否发生交换的标志        for(int j=n-1;j&gt;i;j--)//一趟冒泡过程            if(A[j-1]&gt;A[j])&#123;//若为逆序                swap(A[j-1],A[j]);//交换                flag=true            &#125;        if(flag==false)            return;//本趟遍历后没有发生交换，说明表已经有序    &#125;&#125;\nA[j-1]&gt;A[j]没有等号——只有A[j-1]&gt;A[j]时才交换，因此算法是稳定的j&gt;i——i所指位置之前的元素都已有序bool flag——如果某一趟排序过程中未发生“交换”，则算法可提前结束\n算法性能分析空间复杂度：O(1)时间复杂度最好情况（有序）：O(n)最坏情况（逆序）：每次交换都需要移动元素3次平均时间复杂度&#x3D;O(n²)\n注：冒泡排序同样适用于链表\n\n\n\n8.3.2_快速排序过程：开始时low和high指针分别指向最左和最右，选取第一个元素为基准（枢轴），提出来，此时low指针指向空，看high指针，若high指针所指元素比基准小，该元素移到low所指位置，low指针右移（否则high指针一直左移）…最终，当low&#x3D;&#x3D;high时一次划分结束左边放小于，右边放大于等于\n\n算法实现//快速排序void QuickSort(int A[],int low,int high)&#123;    if(low&lt;high)&#123;//递归跳出的条件        int pivotpos=Partition(A,low,high);//划分        QuickSort(A,low,pivotpos-1);//划分左子表        QuickSort(A,pivotpos+1,high);//划分右子表    &#125;&#125;\n//用第一个元素将待排序序列划分成左右两个部分int Partition(int A[],int low,int high)&#123;    int pivot=A[low];//第一个元素作为枢轴    while(low&lt;high)&#123;//用low、high搜索枢轴的最终位置        while(low&lt;high&amp;&amp;A[high]&gt;=pivot) --high;        A[low]=A[high];//比枢轴小的元素移动到左端         while(low&lt;high&amp;&amp;A[low]&lt;=pivot) ++low;        A[high]=A[low];//比枢轴大的元素移动到右端    &#125;    A[low]=pivot;//枢轴元素存放到最终位置    return low;//返回存放枢轴的最终位置&#125;\n算法效率分析时间复杂度&#x3D;O(n*递归层数)空间复杂度&#x3D;O(递归层数)最好时间复杂度&#x3D;O(nlog₂(n))最坏时间复杂度&#x3D;O(n²)平均时间复杂度&#x3D;O(nlog₂(n))最好空间复杂度&#x3D;O(log₂(n))最坏空间复杂度&#x3D;O(n)\n比较好的情况\n比较坏的情况\n快速排序是所有内部排序算法中平均性能最优的排序算法\n\n\n稳定性不稳定\n\n8.4.1_简单选择排序选择排序——简单选择排序、堆排序选择排序：每一趟在待排元素中选取关键字最小（或最大）的元素加入有序子序列\n\n算法实现//简单选择排序void SelectSort(int A[],int n)&#123;    for(int i=0;i&lt;n-1;i++)&#123;        int min=i;        for(int j=i+1;i&lt;n;j++)            if(A[j]&lt;A[min]) min=j;        if(min!=i) swap(A[i],A[min]);    &#125;&#125;\n算法性能分析空间复杂度&#x3D;O(1)时间复杂度&#x3D;O(n²)无论有序、逆序、还是乱序，一定需要n-1趟处理总共需要对比关键字(n-1)+(n-2)+…+1&#x3D;n(n-1)&#x2F;2次元素交换次数&lt;n-1\n稳定性不稳定\n适用性既可以用于顺序表，也可用于链表\n\n8.4.2_1 堆排序\n什么是“堆（Heap）”\n如何基于“堆”进行排序堆顶元素关键字最大若能把数组整理成堆形式，可简化选择排序\n建立大根堆思路：把所有非终端结点都检查一遍，是否满足大根堆的要求，如果不满足，则进行调整在顺序存储的完全二叉树中，非终端结点编号i&lt;&#x3D;[n&#x2F;2]从后往前检查非终端结点是否满足大根堆的要求，若不满足，将当前结点与更大的一个孩子互换若元素互换破坏的下一级的堆，则采用相同的方法继续往下调整（小元素不断“下坠”）代码实现  //建立大根堆void BuildMaxHeap(int A[],int len)&#123;    for(int i=len/2;i&gt;0;i--)//从后往前调整所有非终端结点        HeadAdjust(A,i,len);&#125;\n  //将以k为根的子树调整为大根堆void HeadAdjust(int A[],int k,int len)&#123;    A[0]=A[k];//A[0]暂存子树的根结点    for(int i=2*k;i&lt;=len;i*=2)&#123;//沿key较大的子结点向下筛选        if(i&lt;len&amp;&amp;A[i]&lt;A[i+1])            i++;//取key较大的子结点的下标        if(A[0]&gt;=A[i]) break;//筛选结束        else&#123;            A[k]=A[i];//将A[i]调整到双亲结点上            k=i;//修改k值，以便继续向下筛选        &#125;    &#125;    A[k]=A[0];//被筛选结点的值放入最终位置&#125;\n基于大根堆进行排序代码实现//建立大根堆void BuildMaxHeap(int A[],int len)//将以k为根的子树调整为大根堆void HeadAdjust(int A[],int k,int len)//堆排序的完整逻辑void HeapSort(int A[],int len)&#123;    BuildMaxHeap(A,len);//初始建堆    for(int i=len;i&gt;1;i--)&#123;//n-1趟的交换和建堆过程        swap(A[i],A[1]);//堆顶元素和堆底元素交换        HeadAdjust(A,1,i-1);//把剩余的待排序元素整理    &#125;&#125;\n算法效率分析建堆的过程，关键字对比次数不超过4n，建堆复杂度&#x3D;O(n)\n稳定性堆排序是不稳定的\n\n8.4.2_2_堆的插入删除\n在堆中插入新元素对于小根堆，新元素放到表尾，与父结点对比，若新元素比父结点更小，则将二者互换。新元素就这样一路“上升”，直到无法继续上升为止\n在堆中删除元素被删除的元素用堆底元素替代，然后让该元素不断“下坠”，直到无法下坠为止\n注意关键字的对比次数\n\n\n\n","categories":["408"],"tags":["数据结构"]},{"title":"web开发","url":"/2025/10/13/web%E5%BC%80%E5%8F%91/","content":"web开发javascript方括号括起来的是数组，大括号括起来的是对象句子后面可有分号也可没有分号\nVueVue是一款用于构建用户界面的渐进式的JavaScript框架（基于数据渲染出用户看到的界面）编写时选择第二个data可自动补全\n常用指令\n\nv-for\n语法：  &lt;tr v-for=&quot;(item，index) in items&quot; :key=&quot;item.id&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/tr&gt;\n参数说明  items为遍历的数组  item为遍历出来的元素  index为索引&#x2F;下标，从0开始；可以省略，省略index语法：  v-for=&quot;item in items&quot;\nkey  作用：给元素添加唯一标识，便于vue进行列表项的正确排序复用，提升渲染性能  推荐使用id作为key（唯一），不推荐使用index作为key（会变化，不对应）\n\n\nv-bind插值表达式不能出现在标签内部，因此不能用v-for渲染图像\n作用  动态为HTML标签绑定属性值，如设置href，src，style样式等\n语法  v-bind:属性名=&quot;属性值&quot;\n简化  :属性名=&quot;属性值&quot;\n\n\nv-if &amp; v-show\n作用  这两类指令，都是用来控制元素的显示与隐藏的\nv-if\n语法          - **原理**            &lt;font color=red&gt;基于条件判断，来控制创建或移除元素节点（条件渲染）&lt;/font&gt;    &gt; v-else-if必须出现在v-if之后，可以出现多个；v-else必须出现在v-if/v-else-if之后    - **v-show**        - **语法**            ```v-show=&quot;表达式&quot;```,表达式值为true，显示；false，隐藏        - **原理**            &lt;font color=red&gt;基于CSS样式display来控制显示与隐藏&lt;/font&gt;- **v-model**    - **作用**        在表单元素上使用，&lt;font color=red&gt;双向数据绑定&lt;/font&gt;。可以方便地&lt;font color=red&gt;获取或设置&lt;/font&gt;表单项数据    - **语法**        ``v-model=&quot;变量名&quot;```        &gt; v-model中绑定的变量，必须在data中定义- **v-on**    - **作用**        为html标签绑定事件（添加事件监听）    - **语法**        ```v-on:事件名=&quot;方法名&quot;```        简写为```@事件名=&quot;...&quot;```## Ajax### 什么是Ajax- **介绍**    Asynchronous Javascript And XML，异步的JavaScript和XML- **作用**    - **数据交换**        通过Ajax可以给服务器发送请求，并获取服务器响应的数据    - **异步交互**        可以在&lt;font color=red&gt;不重新加载整个页面&lt;/font&gt;的情况下，与服务器交换数据并&lt;font color=red&gt;更新部分网页&lt;/font&gt;的技术，如：搜索联想、用户名是否可用的校验等等&gt; XML：（英语：Extensible Markup Language）可扩展标记语言，本质是一种数据格式，可以用来存储复杂的数据结构### 同步与异步![](https://pic1.imgdb.cn/item/690c88de3203f7be00dbf289.png)### AxiosAxios对原生的Ajax进行了封装，简化书写，快速开发![](https://pic1.imgdb.cn/item/690c8a6a3203f7be00dbf387.png)- **请求方式别名**![](https://pic1.imgdb.cn/item/690c8b3a3203f7be00dbf3be.png)- **async&amp;await**    可以通过async、await让异步变为同步操作。async就是来声明一个异步方法，await是用来等待异步任务执行    &gt; await关键字只在async函数内有效，await关键字取代then函数，等待获取到请求成功的结果值- **Vue生命周期**![](https://pic1.imgdb.cn/item/690c90a83203f7be00dbf576.png)## SpringBootWeb### 入门程序- **需求**    基于SpringBoot开发一个Web应用，浏览器发起请求/hello之后，给浏览器返回一个字符串&quot;Hello Xxx&quot;。- **步骤**    1. 创建springboot工程，并勾选web开发相关依赖    2. 定义HelloController类，添加方法 hello，并添加注解    ![](https://pic1.imgdb.cn/item/6908b0e13203f7be00cc6b1d.png)---为什么一个main方法就将web应用启动了![](https://pic1.imgdb.cn/item/6908b2903203f7be00cc7041.png)引入web开发起步依赖后，tomcat服务器相关依赖也传递下来了，运行main方法后启动了tomcat服务器，启动后会将项目代码部署在服务器中，8080就是tomcat的监听端口### HTTP协议概念：Hyper Test Transfer Protocol，超文本传输协议，规定了浏览器和服务器之间数据传输的规则![](https://pic1.imgdb.cn/item/6908b3a83203f7be00cc7590.png)- **特点**    1. 基于TCP协议：面向连接，安全    2. 基于请求-相应模型的：一次请求对应一次相应    3. HTTP协议是无状态的协议：对于事务处理没有记忆能力。每次请求-相应都是独立的        - **缺点**：多次请求间不能共享数据        - **优点**：速度快- **HTTP-请求协议**    - **请求数据格式**        ![](https://pic1.imgdb.cn/item/6908b5bb3203f7be00cc77f9.png)        ![](https://pic1.imgdb.cn/item/6908b62b3203f7be00cc786d.png)        POST类型的请求，在请求头后为请求体（中间隔了一个空行）        **请求方式-GET**：请求参数在请求行中，没有请求体，如：/brand/findAll？name=OPPO&amp;status=1.GET请求大小在浏览器中是有限制的        **请求方式-POST**：请求参数在请求体中，POST请求大小是没有限制的    - **请求数据获取**        Web服务器（Tomcat）对HTTP协议的请求数据进行解析，并进行了封装（HttpServletRequest），在调用Controller方法的时候传递给了该方法。这样，就使得程序员不必直接对协议进行操作，让Web开发更加便捷        ![](https://pic1.imgdb.cn/item/690aaed93203f7be00d2a374.png)- **HTTP-响应协议**    - **响应数据格式**        ![](https://pic1.imgdb.cn/item/690ab2ba3203f7be00d2dfa5.png)        ![](https://pic1.imgdb.cn/item/690ab2ca3203f7be00d2e08a.png)    - **响应数据设置**        Web服务器对HTTP协议的响应数据进行了封装（HttpServletResponse），并在调用Controller方法的时候传递给了该方法。这样，就使得程序员不必直接对协议进行操作，让Web开发更加便捷        ![](https://pic1.imgdb.cn/item/690ab7da3203f7be00d32a1c.png)        &gt; 响应状态码和响应头如果没有特殊要求的话，通常不手动设定。服务器会根据请求处理的逻辑，自动设置响应状态码和响应头### SpringBootWeb案例![](https://pic1.imgdb.cn/item/690ac3943203f7be00d3961d.png)### 分层解耦#### 三层架构不进行拆分复用性差，难以维护![](https://pic1.imgdb.cn/item/690c9e873203f7be00dc0636.png)- **controller**    控制层，接收前端发送的请求，对请求进行处理，并响应数据- **service**    业务逻辑层，处理具体的业务逻辑- **dao**    数据访问层（Data Access Object）（持久层），负责数据访问操作，包括数据的增、删、改、查![](https://pic1.imgdb.cn/item/690ca53a3203f7be00dc1de8.png)#### 分层解耦- **耦合（模块间）**衡量软件中各个层/各个模块的依赖关联程度- **内聚（模块内）**软件中各个功能模块内部的功能联系- **软件设计原则**：高内聚低耦合![](https://pic1.imgdb.cn/item/690ca7403203f7be00dc2302.png)- **控制反转**    Inversion Of Control，简称&lt;font color=red&gt;IOC&lt;/font&gt;。对象的创建控制权由程序自身转移到外部（容器），这种思想称为控制反转- **依赖注入**    Dependency Injection，简称&lt;font color=red&gt;DI&lt;/font&gt;。容器为应用程序提供运行时，所依赖的资源，称之为依赖注入- **Bean对象**    IOC容器中创建、管理的对象，称之为&lt;font color=red&gt;Bean&lt;/font&gt;#### IOC&amp;DI入门1、将Dao及Service层的实现类，交给IOC容器管理```@Component```（注意：是加在实现类上，而非接口上）2、为Controller及Service注入运行时所依赖的对象```@Autowired```#### IOC&amp;DI详解- **IOC详解**    要把某个对象交给IOC容器管理，需要在对应的类上加上如下注解之一    ![](https://pic1.imgdb.cn/item/690cad773203f7be00dc2aa9.png)    &gt; 注意：声明bean的时候，可以通过注解的value属性指定bean的名字，如果没有限定，默认为类名首字母小写    &gt; 注意：在Springboot集成web开发中，声明控制器bean只能用@Controller    前面声明bean的四大注解，要想生效，还需要被组件扫描注解```@ComponentScan```扫描    该注解虽然没有显示配置，但是实际上已经包含在了启动类声明注解```@SpringBootApplication```中，默认&lt;font color=red&gt;扫描的范围是启动类所在包及其子包&lt;/font&gt;- **DI详解**    基于@Autowired进行依赖注入的常见方式有如下三种    ![](https://pic1.imgdb.cn/item/690cb58a3203f7be00dc4444.png)    方式二如果当前类中只存在一个构造函数，```@Autowired```可以省略    - **属性注入**        优点：代码简洁、方便快速开发        缺点：隐藏了类之间的依赖关系、可能会破坏类的封装性    - **构造函数注入**        优点：能清晰地看到类的依赖关系、提高了代码的安全性        缺点：代码繁琐、如果构造参数过多，可能会导致构造函数臃肿    - **setter注入**        优点：保持了类的封装性，依赖关系更清晰        缺点：需要额外编写setter方法，增加了代码量    - @Autowired注解，默认是按照&lt;font color=red&gt;类型&lt;/font&gt;进行注入的- 如果存在多个相同类型的bean，将会报错解决方案：![](https://pic1.imgdb.cn/item/690cbb243203f7be00dc502c.png)@Resource与@Autowired区别？  1. @Autowired是Spring框架提供的注解，而@Resource是JavaEE规范提供的  2. @Autowired默认是按照类型注入，而@Resource默认是按照名称注入### JDBCJDBC：（Java DataBase Connectivity），就是使用Java语言操作关系型数据库的一套API![](https://pic1.imgdb.cn/item/690cbdbe3203f7be00dc58bf.png)- **本质**    - sun公司官方定义的一套操作所有关系型数据库的规范，即接口    - 各个数据库厂商去实现这套接口，提供数据库&lt;font color=red&gt;驱动jar包&lt;/font&gt;    - 我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类  ![](https://pic1.imgdb.cn/item/690cbee13203f7be00dc5fe7.png)```java// 1、注册驱动Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);// 2、获取数据库连接Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/web01&quot;, &quot;root&quot;, &quot;123456&quot;);// 3、获取SQL语句执行对象Statement statement = connection.createStatement();// 4、执行SQLint i = statement.executeUpdate(&quot;update user set age = 25 where id = 1&quot;);//DMLSystem.out.println(&quot;SQL执行完毕影响的记录数为： &quot;+i);// 5、释放资源statement.close();connection.close();\n\n\n\n\nJDBC-查询数据\nResultSet（结果集对象）：ResultSet rs = statement.executeQuery()\nnext()：将光标从当前位置移动一行，并判断当前行是否为有效行，返回值为boolean\ntrue：有效行，当前行有数据\nfalse：无效行，当前行没有数据\n\n\ngetXxx(…)：获取数据，可以根据列的编号获取，也可以根据列名获取（推荐）\n结果解析步骤  while (resultSet.next()) &#123;    int id = resultSet.getInt(&quot;id&quot;);    //...省略&#125;\n\n\n预编译SQL\n优势一  可以防止SQL注入，更安全  SQL注入：通过控制输入来修改事先定义好的SQL语句，以达到执行代码对服务器进行攻击的方法（比如：登录时若密码输入&#39; or &#39;1&#39; = &#39;1可直接登录）\n优势二  \n\n\n\nMyBatisMyBatis是一款优秀的持久层框架，用于简化JDBC的开发\n\nJDBC vs Mybatis\n\n数据库连接池（类似线程池）\n数据库连接池是个容器，负责分配、管理数据库连接（Connection）\n它允许应用程序重复使用一个现有的数据库连接，而不是再建立一个\n释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏\n优势\n资源重用\n提升系统响应速度\n避免数据库连接遗漏\n\n\n标准接口：DataSource\n官方（sun）提供的数据库连接池接口，由第三方组织实现此接口\n功能：获取连接  \nDruid（德鲁伊）\nDruid连接池是阿里巴巴开源的数据库连接池项目\n功能强大，性能优秀，是Java语言最好的数据库连接池之一\n\n\n\n\n切换数据库连接池  &lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.2.19&lt;/version&gt;&lt;/dependency&gt;\n  spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.url=jdbc:mysql://localhost:3306/web01spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.username=rootspring.datasource.password=123456\n\nXML映射配置\n\n使用Mybatis的注解，主要是来完成一些简答的增删改查功能。如果需要实现复杂的SQL功能，建议使用XML来配置映射语句\n\n\n辅助配置配置XML映射文件的位置\n\nmabatis.mapper-locations=classpath:mapper/*.xml配置之后可在不同包下\nspringboot项目配置文件\n配置文件格式  SpringBoot项目提供了多种属性配置方式（properties、yaml、yml）\nyml配置文件\n格式\n数值前边必须有空格，作为分隔符\n使用缩进表示层级关系，缩进时，不允许使用tab键，只能用空格（idea中会自动将Tab转换为空格）\n缩进的空格数目不重要，只要相同层级的元素左侧对齐即可\n# 表示注释，从这个字符一直到行尾，都会被解析器忽略\n\n\n\n\n\nTlias智能学习辅助系统开发规范-开发模式\n前后端分离开发\n\n开发规范-Restful风格REST（REpresentational State Transfer），表述性状态转换，它是一种软件架构风格\n\nRest是风格，是约定方式，约定不是规定，可以打破\n\n\n描述功能模块通常使用复数形式（加s），表示此类资源，而非单个资源。如：users、books…\n\n\n\n思考\n前后端都在并行开发，后端开发完对应的接口之后，如何对接口进行请求测试呢？\n前后端都在并行开发，前端开发过程中，如何获取到数据，测试页面的渲染展示呢？\n\n\nApifox\n介绍：Apifox是一款集成了Api文档、Api调试、Api Mock、Api测试的一体化协作平台\n作用：接口文档管理、接口请求测试、Mock服务\n\n\n\n部门管理工程搭建\n数据封装\n实体类属性名和数据库查询返回的字段名一致，mybatis会自动封装\n如果实体类属性名和数据库表查询返回的字段名不一致，不能自动封装\n手动结果映射：通过@Results及@Result进行手动结果映射  @Results(&#123;     @Result(column = &quot;create_time&quot; , property = &quot;createTime&quot;),     @Result(column = &quot;update_time&quot; , property = &quot;updateTime&quot;) &#125;) @Select(&quot;select id,name,create_time,update_time from dept order by update_time desc&quot;) public List&lt;Dept&gt; findAll();\n起别名：在SQL语句中，对不一样的列名起别名，别名和实体类属性名一样  @Select(&quot;select id,name,create_time createTime,update_time updateTime from dept order by update_time desc&quot;)public List&lt;Dept&gt; findAll();\n开启驼峰命名：如果字段名与属性名符合驼峰命名规则，mybatis会自动通过驼峰命名规则映射    mybatis:configuration:  log-impl: org.apache.ibatis.logging.stdout.StdOutImpl  #开启驼峰命名映射开关  map-underscore-to-camel-case: true\n\n前后端联调测试\n前端工程请求服务器的地址为http://localhost:90/api/depts，是如何访问到后端的tomcat服务器的？  \n反向代理是一种网络架构，通过代理服务器为后端的服务器做代理，客户端的请求直接请求代理服务器，然后转发给后端的服务器（安全、灵活（前端对后端服务器的改变无感知）、负载均衡）\n\n  \nlocation：用于定义匹配路径匹配的规则\n^~&#x2F;api&#x2F;：表示精确匹配，即只匹配以&#x2F;api&#x2F;开头的路径\nrewrite：该指令用于重写匹配到的路径（后面的代替前面的，去掉api）\nproxy_pass：该指令用于代理转发，它将匹配到的请求转发给位于后端的指令服务器\n\n\n\n删除部门\nController接收参数\n方式一：通过原始的HttpservletRequest对象获取请求参数  @DeleteMapping(&quot;/depts&quot;)public Result delete(HttpServletRequest request)&#123;    String idStr=request.getParameter(&quot;id&quot;);    int id=Integer.parseInt(idStr);    System.out.println(&quot;根据ID删除部门&quot;+id);    return Result.success();&#125;\n方式二：通过Spring提供的@RequestParam注解，将请求参数绑定给方法形参  // 注意事项：一旦声明了@RequestParam，该参数在请求时必须传递，如果不传递将会报错（默认 required 为 true）@DeleteMapping(&quot;/depts&quot;)public Result delete(@RequestParam(value = &quot;id&quot; , required = false) Integer deptId)&#123;    System.out.println(&quot;根据ID删除部门：&quot;+deptId);    return Result.success();&#125;\n方法三：如果请求参数名与形参变量名相同，直接定义方法形参即可接收（省略@RequestParam）  @DeleteMappingpublic Result delete(Integer id)&#123;    System.out.println(&quot;根据ID删除部门：&quot;+id);    return Result.success();&#125;\n\n\n\n新增部门\nController接收参数\nJSON格式的参数，通常会使用一个实体对象进行接收\n规则：JSON数据的键名与方法形参对象的属性名相同，并需要使用@RequestBody注解标识  @PostMappingpublic Result add(@RequestBody Dept dept)&#123;    System.out.println(&quot;新增部门：&quot;+dept);    deptService.add(dept);    return Result.success();&#125;\n\n\n\n修改部门\nController接收参数\n路径参数：通过请求URL直接传递参数，使用{…}来标识该路径参数，需要使用@PathVariable获取  @GetMapping(&quot;/depts/&#123;id&#125;&quot;)public Result getInfo(@PathVariable(&quot;id&quot;) Integer deptId)&#123;    System.out.println(&quot;根据ID查询部门：&quot;+ deptId);    return Result.success();&#125;\n  若形参名称与路径参数参数名一致，可简化为 public Result getInfo(@PathVariable Integer deptId)\n\n\nRequestMapping  RequestMapping注解可加在\n类上（可选的）\n方法上\n一个完整的请求路径&#x3D;类上+方法上的\n\n\n\n日志技术程序中的日志，是用来记录应用程序的运行信息、状态信息、错误信息等功能：数据追踪、性能优化、问题排查、系统监控\n\nJUL（java.util.logging）：这是JavaSE平台提供的官方日志框架，也被称为JUL。配置相对简单，但不够灵活，性能较差\nLog4j：一个流行的日志框架，提供了灵活的配置选项，支持多种输出目标\nLogback：基于Log4j升级而来，提供了更多的功能和配置选项，性能优于Log4j\nSLf4j（Simple Logging Facade for Java）：简单日志门面，提供了一套日志操作的标准接口及抽象类，允许应用程序使用不同的底层日志框架\n\nLogback\n准备工作：引入logback的依赖（springboot项目中该依赖已传递）、配置文件logback.xml\n记录日志：定义日志记录对象Logger，记录日志\n\nprivate static final Logger log = LoggerFactory.getLogger(LogTest.class)\n\n在类前加上@Slf4j注解可不用定义对象\n\nLogback配置文件&amp;日志级别配置文件\n配置文件名：logback.xml\n该配置文件是对Logback日志框架输出的日志进行控制的，可以来配置输出的格式、位置及日志开关等\n常用的两种输出日志的位置：控制台、系统文件  &lt;!-- 控制台输出 --&gt;&lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;...&lt;/appender&gt;\n  &lt;!-- 系统文件输出 --&gt;&lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;...&lt;/appender&gt;\n开启日志（ALL），关闭日志（OFF）  &lt;root level=&quot;info&quot;&gt;&lt;appender-ref ref=&quot;STDOUT&quot; /&gt;&lt;appender-ref ref=&quot;FILE&quot; /&gt;&lt;/root&gt;\n\n日志级别日志级别指的是日志信息的类型，日志都会分级别，常见的日志级别如下（级别由低到高）\n\n大于等于配置的日志级别的日志才会输出\n\n员工管理分页查询\npageHelperpageHelper是第三方提供的在Mybatis框架中用来实现分页的插件，用来简化分页操作，提高开发效率\n\n使用步骤\n引入PageHelper的依赖\n定义Mapper接口的查询方法（无需考虑分页）\n在Service方法中实现分页查询    拿到total数据： Page&lt;Emp&gt; p = (Page&lt;Emp&gt;)empList;total = p.getTotal();\n\n\n实现机制\n注意事项：a.SQL语句结尾不要加分号（；） b.PageHelper只会对紧跟在其后的第一条SQL语句进行分页处理\n\n\n\n条件分页查询\n- **请求参数接收优化**    如果controller方法的参数较多，且未来可能继续增加，这会使得方法签名变得复杂难以维护，此时可以考虑将多个请求参数封装为一个对象    ![](https://pic1.imgdb.cn/item/691726a43203f7be0003ea5f.png)- **动态SQL**      随着用户的输入或外部条件的变化而变化的SQL语句，我们成为**动态SQL**    - **\\&lt;if&gt;**：判断条件是否成立，如果条件为true，则拼接SQL        ```xml        &lt;if test=&quot;gender != null&quot;&gt;            and e.gender=#&#123;gender&#125;        &lt;/if&gt;\n- **\\&lt;where&gt;**：根据查询条件，来生成where关键字，并会自动去除条件前面多余的and或or\n- **\\&lt;foreach&gt;**\n    &lt;insert id=&quot;insertBatch&quot;&gt;    insert into emp_expr(emp_id, begin, end, company, job) values    &lt;foreach collection=&quot;exprList&quot; item=&quot;expr&quot; separator=&quot;,&quot;&gt;        (#&#123;expr.empId&#125;,#&#123;expr.begin&#125;, #&#123;expr.end&#125;, #&#123;expr.company&#125;, #&#123;expr.job&#125;)    &lt;/foreach&gt;&lt;/insert&gt;\n    1. collection：集合名称\n    2. item：集合遍历出来的元素/项\n    3. separator：每一次遍历使用的分隔符\n    4. open：遍历开始前拼接的片段\n    5. close：遍历结束后拼接的片段\n\n事务\n注解：@Transaction\n作用：将当前方法交给spring进行事务管理，方法执行前，开启事务；成功执行完毕，提交事务；出现异常，回滚事务\n位置：业务（service）层的方法上、类上、接口上\n- **rollbackFor** rollbackFor属性用于控制出现何种异常类型，回滚事务```@Transactional(rollbackFor = &#123;Exception.class&#125;)```若没有声明rollbackFor属性,默认出现运行时异常RuntimeException才会回滚- **propagation**事务传播行为：指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行事务控制![](https://pic1.imgdb.cn/item/6917de403203f7be000510b1.png)![](https://pic1.imgdb.cn/item/6917e7df3203f7be00056a5e.png)### 文件上传前端：```html&lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;   姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;br&gt;   年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt; &lt;br&gt;   图像：&lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;br&gt;   &lt;input type=&quot;submit&quot; value=&quot;上传文件&quot; name=&quot;submit&quot;&gt;&lt;/form&gt;\n服务器端：\n\n@Slf4j@RestControllerpublic class UploadController&#123;    @PostMapping(&quot;/upload&quot;)    public Result handlerFileUpload(String name,Integer age,MultipartFile file)&#123;        log.info(&quot;文件上传：&#123;&#125;&quot;,file);        return Result.success();    &#125;&#125;\n\n\n\n本地存储@PostMapping(&quot;/upload&quot;)public Result upload(String name, Integer age, MultipartFile file) throws IOException &#123;    log.info(&quot;接收参数：&#123;&#125;.&#123;&#125;,&#123;&#125;&quot;,name,age,file);    //获取原始文件名    String originalFilename = file.getOriginalFilename();    //新的文件名    String extension = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));    String newFileName = UUID.randomUUID().toString() + extension;    //保存文件    file.transferTo(new File(&quot;D:/images/&quot;+ newFileName));    return Result.success();&#125;\n\n如何将上传的文件存储在服务器本地\nmultipartFile.getOriginalFilename()：获取原始文件名\nmultipartFile.transferTo(File dest)：将文件转存到磁盘文件\n\n\n上传文件大小受限怎么办  默认上传文件的最大大小为1MB，超过大小需要在配置文件配置  spring:  servlet:    multipart:      #最大单个文件大小      max-file-size: 10MB      #最大请求大小（包括所有文件和表单数据）      max-request-size: 100MB\n\n阿里云OSS（Object Storage Service）\n\n案例集成\n引入阿里云OSS文件上传工具类（由官方的示例代码改造而来）\n上传文件接口开发  @Autowiredprivate AliyunOSSOperator aliyunOSSOperator;//文件上传@PostMapping(&quot;/upload&quot;)public Result upload(MultipartFile file) throws Exception &#123;    log.info(&quot;文件上传：&#123;&#125;&quot;,file.getOriginalFilename());    //将文件交给OSS存储管理    String url = aliyunOSSOperator.upload(file.getBytes(), file.getOriginalFilename());    log.info(&quot;文件上传OSS，url：&#123;&#125;&quot;,url);    return Result.success(url);&#125;\n\n\n参数配置化  指将一些需要灵活变化的参数，配置在配置文件中，然后通过@Value注解来注入外部配置的属性  aliyun:  oss:    endpoint: http://oss-cn-beijing.aliyuncs.com    bucketName: java-hz-web    region: cn-beijing\n  @Componentpublic class AliyunOSSOperator &#123;    @Value(&quot;$&#123;aliyun.oss.endpoint&#125;&quot;)    private String endpoint;    @Value(&quot;$&#123;aliyun.oss.bucketName&#125;&quot;)    private String bucketName;    @Value(&quot;$&#123;aliyun.oss.region&#125;&quot;)    private String region;&#125;\n  问题分析：使用@Value注解注入配置文件的配置项，如果配置项多，注入繁琐，不便于维护管理和复用\n@ConfigurationProperties\n如果属性较少，建议@Value注入即可，如果属性较多，考虑复用，建议使用@ConfigurationProperties\n\n\n\n删除员工需求：删除单个员工和批量删除\n\n其实，删除单条数据也是一种特殊的批量删除，所以，删除员工的功能，只需要开发一个接口就可以了\n\n\nController接收请求参数\n方式一：在Controller方法中通过数组来接收  @DeleteMappingpublic Result delete(Integer[] ids)&#123;    log.info(&quot;删除员工：&#123;&#125;&quot;, Arrays.toString(ids));    return Result.success();&#125;\n方式二：在Controller方法中通过集合来接收  @DeleteMappingpublic Result delete(@RequestParam List&lt;Integer&gt;ids)&#123;    log.info(&quot;删除员工：&#123;&#125;&quot;, ids);    return Result.success();&#125;\n\n方式二更为常用，此时@RequestParam参数不可省略\n\n\n\n\n\n修改员工查询回显根据ID查询员工信息时，员工工作经历信息有多条，此时mybatis不会将emp_expr封装到emp对象的数组中，而是会封装到两个对象中\n\n解决方案  不再使用resultType，而是使用resultMap结果集  &lt;!--自定义结果集ResultMap--&gt;&lt;resultMap id=&quot;empResultMap&quot; type=&quot;com.hz.pojo.Emp&quot;&gt;    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;    &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;    &lt;result column=&quot;password&quot; property=&quot;password&quot;/&gt;    &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;    &lt;result column=&quot;gender&quot; property=&quot;gender&quot;/&gt;    &lt;result column=&quot;phone&quot; property=&quot;phone&quot;/&gt;    &lt;result column=&quot;job&quot; property=&quot;job&quot;/&gt;    &lt;result column=&quot;salary&quot; property=&quot;salary&quot;/&gt;    &lt;result column=&quot;image&quot; property=&quot;image&quot;/&gt;    &lt;result column=&quot;entry_date&quot; property=&quot;entryDate&quot;/&gt;    &lt;result column=&quot;dept_id&quot; property=&quot;deptId&quot;/&gt;    &lt;result column=&quot;create_time&quot; property=&quot;createTime&quot;/&gt;    &lt;result column=&quot;update_time&quot; property=&quot;updateTime&quot;/&gt;    &lt;!--封装工作经历信息--&gt;    &lt;collection property=&quot;exprList&quot; ofType=&quot;com.hz.pojo.EmpExpr&quot;&gt;        &lt;id column=&quot;ee_id&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;ee_empid&quot; property=&quot;empId&quot;/&gt;        &lt;result column=&quot;ee_begin&quot; property=&quot;begin&quot;/&gt;        &lt;result column=&quot;ee_end&quot; property=&quot;end&quot;/&gt;        &lt;result column=&quot;ee_company&quot; property=&quot;company&quot;/&gt;        &lt;result column=&quot;ee_job&quot; property=&quot;job&quot;/&gt;    &lt;/collection&gt;&lt;/resultMap&gt;\n  column：字段  property：属性\n如果查询返回的字段名与实体的属性名可以直接对应上，用resultType  如果查询返回的字段名与实体的属性名对应不上，或实体属性比较复杂，可以通过resultMap手动封装\n\n\n\n修改数据修改工作经历：先删再加\n","categories":["Java"],"tags":["Javaweb"]},{"title":"计算机组成原理","url":"/2025/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/","content":" 计算机组成原理导论\n计算机&#x2F;手机组成\n计算机硬件能识别的数据——二进制0&#x2F;1用低&#x2F;高电平分别表示0&#x2F;1硬件间通过主板上的印刷电路，可以传递多个二进制数位，每个二进制数位称为1bit\n\n一、计算机系统概述计算机系统&#x3D;硬件+软件\n1.1 计算机的发展\n软件：\n\n系统软件——用来管理整个计算机系统（Eg.操作系统、数据库管理系统（DBMS）、标准程序库、网络软件（网卡驱动等）、语言处理程序、服务程序（Debug等））\n应用软件——按任务需要编织成的各种程序\n\n\n硬件\n\n\n\n第一代：电子管时代第一台电子数字计算机：ENIAC（1946），冯诺依曼逻辑元件：电子管使用机器语言编程\n第二代：晶体管时代逻辑元件：晶体管体积、功耗降低出现面向过程的程序设计语言有了操作系统雏形\n第三代：中小规模集成电路时代高级语言迅速发展，有了分时操作系统\n第四代：大规模、超大规模集成电路时代开始出现微处理器（CPU）、微型计算机、个人计算机（PC）萌芽操作系统：Windows、MacOS、Linux\n\n\n\n微处理器的发展微型计算机的发展以微处理器技术为标志机器字长：计算机一次整数运算所能处理的二进制位数（目前都是64位）\n硬件的发展“八叛徒”创立“仙童”,仙童半导体公司发明“集成电路”,摩尔离开后创立Intel，“仙童”中另一成员桑德斯创立AMD“摩尔定律”:每18个月性能翻倍\n\n1.2.1 计算机硬件的基本组成\n早期冯诺依曼机ENIAC（手动接线来控制计算）冯诺依曼提出存储程序概念：将指令以二进制代码的形式事先输入计算机的主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束——&gt;第一台采用冯诺依曼结构的计算机EDVAC\n冯诺依曼计算机的特点\n\n\n计算机由五大部件组成\n指令和数据以同等地位存于存储器，可按地址寻访\n指令和数据用二进制表示\n指令由操作码和地址码组成\n存储程序\n以运算器为中心（输入&#x2F;输出设备与存储器之间的数据传送通过运算器完成）\n\n\n现代计算机的结构 现代计算机：以存储器为中心CPU&#x3D;运算器+控制器\n主存即内存\n辅存：app存放在辅存，只有app启动运行后才会把相关代码程序数据读到主存\n\n\n\n\n\n1.2.2 各个硬件的工作原理\n主存储器的基本组成读操作：写操作：存储体中存的是数据+指令（操作码+地址码）\n运算器的基本组成ACC、MQ、X均为寄存器核心部件为ALU\n控制器的基本组成\n\n\n\n计算机的工作过程\n\n\n\n1.2.3 计算机软件软件&#x3D;系统软件+应用软件\n\n三种级别的语言高级语言（源程序）-&gt;（通过编译程序（编译器））汇编语言（助记符）-&gt;（通过汇编程序（汇编器））机器语言（二进制代码）\n一些编程语言可以通过编译程序（编译器）直接将源程序翻译成机器语言\n还有一些编程语言（JavaScript、Python、Shell）通过解释程序（解释器）将源程序翻译成机器语言\n编译程序：将高级语言编写的源程序全部语句一次全部翻译成机器语言程序，而后再执行机器语言程序（只需翻译一次）\n解释程序：将源程序的一条语句翻译成对应于机器语言的语句，并立即执行。紧接着再翻译下一句（每次执行都要翻译）\n\n\n\n\n\n注：&#x3D;&#x3D;编译器、汇编器、解释器&#x3D;&#x3D;可统称“&#x3D;&#x3D;翻译程序&#x3D;&#x3D;”\n\n软件和硬件的逻辑功能等价性同一个功能，既可以用硬件实现（性能高成本高），也可以用软件实现（性能低成本也低）Eg：实现一个乘法，若硬件支持“乘法指令”，则可直接用硬件，若硬件只支持加法指令，则可用软件编写6条“加法指令”\n指令集体系结构（ISA：Instruction Set Architecture）： 软件和硬件之间的界面（分界），设计计算机系统的ISA，就是要定义一台计算机可以支持哪些指令，以及每条指令的作用是什么，每条指令的用法是什么\n\n\n\n1.2.4 计算机系统的层次结构\n1.2.5 计算机系统的工作原理\n1.3 计算机的性能指标\n存储器的性能指标总容量&#x3D;存储单元个数x存储字长 bit&#x3D;存储单元个数x存储字长&#x2F;8 ByteEg：MAR为32位，MDR为8位，总容量&#x3D;2的32次方*8 bit&#x3D;4GB\n\nCPU的性能指标Eg：翼龙15pro参数：AMD Ryzen 7 8845H&#x2F;3.8GHz（CPU主频）&#x2F;八核十六线程\n\nCPU主频：CPU内数字脉冲信号振荡的频率（单位：Hz）CPU主频（时钟频率）&#x3D;1&#x2F;CPU时钟周期（单位：微秒、纳秒）每个动作至少要1个时钟周期\nCPI（Clock cycle Per Instruction）：执行一条指令所需的时钟周期数（不同的指令CPI不同，甚至相同的指令，CPI也可能有变化）\n执行一条指令的耗时&#x3D;CPIxCPU时钟周期\nCPU执行时间（整个程序的耗时）&#x3D;CPU时钟周期数&#x2F;主频&#x3D;（指令条数*CPI）&#x2F;主频\nIPS（KIPS、MIPS）（Instruction Per Second）：每秒执行多少条指令IPS&#x3D;主频&#x2F;平均CPI\nFLOPS（KFLOPS、MFLOPS、GFLOPS、TFLOPS）（Floating-point Operation Per Second）：每秒执行多少次浮点运算\n注：此处K、M、G、T为数量单位，与KB、MB、GB不同\n\n\n\n\n系统整体的性能指标\n\n静态指标\n\n\n数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）\n吞吐量：指系统在单位时间内处理请求的数量\n响应时间：指从用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需要的结果的等待时间，通常包括CPU时间与等待时间\n\n\n动态指标基准程序（跑分软件）是用来测量计算机处理速度的一种实用程序，以便于被测量的计算机性能可以与运行相同程序的其它计算机性能进行比较\n\n\n\n二、数据的表示和运算2.1.1 进位计数制\n位权\n基数 ：每个数码位所用到的不同符号的个数，r进制的基数为r\n十进制-&gt;任意进制整数部分：除基取余小数部分：乘基取整\n真值和机器数（了解）真值：符合人类习惯的数字机器数：数字实际存到机器里的形式，正负号需要被“数字化”\n\n2.1.2+2.1.3 定点数的编码表示定点数：小数点的位置固定（Eg：996.007）浮点数：小数点的位置不固定（Eg：9.96007*10的二次方——科学计数法）\n\n无符号数的表示无符号数：整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的绝对值n位无符号数表示范围为：0~2的n次方-1\n通常只有无符号数整数，而没有无符号数小数（unsigned float报错）\n\n\n有符号数的定点表示最高位为符号位（0正1负），其余为数值部分（尾数）注：可用原码、反码、补码三种方式来表示定点整数和定点小数。还可用移码表示定点整数\n原码由于真值0有+0和-0两种形式，实际只能表示2的n+1次方-1个数\n反码若符号位为0，则反码与原码相同若符号位为1，则数值位全部取反反码的表示范围与原码对应注：“反码”只是“原码”转变为“补码”的一个中间状态 \n补码正数的补码&#x3D;原码负数的补码&#x3D;反码末位+1（要考虑进位）  \n移码补码的基础上将符号位取反注意：移码只能用于表示整数移码的表示范围与补码对应移码作用：真值越大，移码对应的无符号数也在逐一递增，因此，移码表示的整数很方便对比大小（从高位开始对比，谁先出现1谁更大）\n\n\n\n技巧：由[x]补k快速求[-x]补的方法：符号位、数值位全部取反，末位+13. 各种码的作用（拓展）\n\n加减运算\n\n\n若使用原码进行加减运算，正+负要变为正-正，否则结果错误\n加法——用加法器完成 减法——用减法器完成减法器成本高，能否用加法代替减法？\n\n\n用加法代替减法   Eg：-3和+9在mod 12时等价\n数论中余数定义：带余除法——设x，m属于z，m&gt;0则存在唯一决定的整数q和r，使得：x&#x3D;qm+r，0&lt;&#x3D;r&gt;m\n\n\n\n   根据该定义，-3 mod 12&#x3D;9   （mod 12）把所有整数分为12类   在（mod m）的条件下，若能找到负数的补数，就可以用正数的加法来等价替代减法   &#x3D;&#x3D;模-a的绝对值&#x3D;a的补数（补码）&#x3D;&#x3D;   计算机硬件默认完成mod 2的8次方操作\n\n补码的作用：使用补码可将减法操作转变为等价的加法，ALU中无需集成减法器。执行加法操作时，符号位一起参与运算\n移码的作用：移码表示的整数很方便对比大小\n\n2.1.4_1 C语言中的整数类型及类型转换\n2.1.4_1 零扩展、符号扩展为什么要对数据进行长度扩展？\n\n机器字长（Eg：32位）决定通用寄存器位数，因此通用寄存器位数是固定的\nALU的位数是固定的，运算前可能需要把短数据扩展为长数据\n\n\n零扩展适用于无符号整数，用0扩展高位\n符号扩展计算机中带符号整数是以补码的形式存储的适用于带符号整数（补码），用“符号位”扩展高位（补的位与符号位数值相同）\n\n2.2.0_1 逻辑门电路（数字电路基础补充）\n基本逻辑运算\n与 \n或 \n非 \n\n\n复合逻辑运算\n与非 \n或非 \n异或 \n同或 \n\n\n\n- 补充1：门电路的变形画法- 补充2：逻辑运算的优先级、常见公式\n拓展：芯片制程\n\n2.2.0_2 多路选择器、三态门（数字电路基础补充）\n多路选择器（MUX）\n三态门三态门和非门核心区别：“非门”没有控制信号！只有输入和输出若多路选择器有k个输入，则控制信号的位数m&gt;&#x3D;[log2(k)]（向上取整）bit有的多路选择器可能会预留一个控制信号，用于拦截所有输入，此时控制信号的位数m&gt;&#x3D;[log2(k+1)]（向上取整）bit\n\n2.2.1_1 加法器\n如何用门电路实现一位加法\n一位全加器\nn bit加法器\n不足之处由于两个输入端允许并行输入 n bit,因此这种加法器属于：并行加法器由于进位信息是串行产生的，因此从“进位方式”看，这种加法器属于：串行进位加法器综上，很多教材把这种加法器称为“串行进位的并行加法器”\n并行进位的并行加法器\n带标志位的加法器\n标志位的生成\n\n2.2.1_3 算术逻辑单元ALU\n算术逻辑单元（ALU）的作用CPU由控制器、运算器组成控制器负责解析指令，并根据指令功能发出相应的控制信号（将在计组第五章详细学习）运算器负责对数据进行处理，如：加减乘除等ALU是一种组合逻辑电路，实现了加减乘除与或非等功能。因此ALU是运算器的核心由于加减乘除等运算都要基于“加法”来实现，因此加法器是ALU的核心\nALU的功能\nALU的实现原理（简单了解即可）\n看懂ALU图示\n\n\n\n2.2.2 定点数的移位运算\n逻辑移位（常用于处理无符号整数）\n逻辑左移：高位移出丢弃，低位补0 对于无符号整数，每逻辑左移一位，则相当于×2 注意：若逻辑左移丢弃的位&#x3D;1，则发生溢出（超出n bit无符号整数的表示范围）\n逻辑右移：低位移出丢弃，高位补0 对于无符号整数，每逻辑右移一位，则相当于÷2 注意：若逻辑右移丢弃的位&#x3D;1，则会丢失精度\n\n\n算数移位（常用于处理带符号整数）\n算数左移：高位移出丢弃，低位补0 对于带符号整数，每算数左移一位，则相当于×2 注意：若算数左移前后的符号位不同，则发生溢出（超出n bit带符号整数的表示范围） \n算数右移：低位移出丢弃，高位补符号位 对于带符号整数，每算数右移一位，则相当于÷2 注意：若算数右移丢弃的位&#x3D;1，则会丢失精度\n\n\n\n2.2.3_1 定点数的加减运算\n原码的加减运算\n补码的加减运算\n溢出判断 1. 方法一  2. 方法二  3. 方法三  \n\n2.2.3_2 无符号数的加减运算\n无符号数的加法运算\n无符号数的减法运算\n无符号数加法&#x2F;减法的溢出判断无符号数加法的溢出判断：最高位产生的进位&#x3D;1时，发生溢出，否则未溢出无符号数减法的溢出判断：最高位产生的进位&#x3D;0时，发生溢出，否则未溢出\n\n2.2.3_3 补码加减运算电路\n补码加减运算电路\n也可用于计算无符号数加减运算\n\n\n\n2.2.4_1 无符号整数的乘法运算原理\n以4bit无符号整数为例\n无符号整数乘法原理：溢出判断、溢出处理\n32位无符号数乘法运算电路的结构\n\n2.2.4_2 带符号整数的乘法运算原理\n以4bit带符号整数为例\n注意是进行算数右移，不是逻辑右移\n\n\n\n\n\n带符号整数乘法原理：溢出判断、溢出处理\n\n为何是OF标志位不是CF标志位？CF标志位一般用来记录加减运算的溢出情况，乘法运算的溢出情况都是用OF标志位\n\n\n32位带符号数乘法运算电路的结构\n\n\n\n补充：本节介绍的“补码一位乘法”由A.D.Booth提出，因此这种算法也被称为布斯（Booth）乘法\n2.2.4_3 计算机实现乘法运算的三种方式\n由ALU、移位器、寄存器、控制逻辑组成的乘法电路\n\n阵列乘法器\n\n阵列乘法器是快速乘法器中的一种。很多“快速乘法器”都可以在1个时钟内完成乘法运算\n\n\n用逻辑运算、加&#x2F;减运算（软件）等效实现乘法\n\n\n\n\n结论（小题、简答题常考）\n\n2.2.4_4 无符号整数的除法运算原理\n以4bit无符号整数为例R-Y的值要先存入余数寄存器R中，要恢复成R时再加上Y即可\n32位无符号数除法运算电路的结构\n关于“商溢出”的进一步探讨\n\n\n概念补充：在x86中，除数为0，商溢出都属于“除法错异常”（Divide Error Exception），也可简译为“除法异常”\n2.3.1_1 浮点数的表示_IEEE 754\n\n从科学计数法理解浮点数尾数“规格化”的好处：便于在计算机内部存储\nIEEE 754标准定义的浮点数格式\nfloat单精度浮点型的存储\ndouble双精度浮点型的存储\n\n2.3.1_3 浮点数的表示范围、几种特殊状态- IEEE：规格化浮点数的表示范围- IEEE：浮点数的上溢（Overflow）- IEEE：无穷大的表示- IEEE 754：浮点数的下溢（Underflow）- IEEE 754：真值0的表示- IEEE 754：非规格化浮点数的表示负数符号取反即可- IEEE 754：非数（NaN）的表示\n","categories":["408"],"tags":["计组"]}]